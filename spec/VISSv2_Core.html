<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>VISS version 2 - Core</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script type="text/javascript" src="plantuml/jquery.js"></script>
    <script type="text/javascript" src="plantuml/jquery_plantuml.js"></script>
    <script type="text/javascript" src="plantuml/rawdeflate.js"></script>	 
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Geotab",
          companyURL: "https://www.geotab.com"
        },
        {
          name: "Ulf Bjorkengren",
          company: "Volvo Cars",
          companyURL: "https://www.volvocars.com/intl"
        },
        {
          name: "Isaac Agudo",
          company: "NICS Lab / University of Malaga",
          companyURL: "https://www.nics.uma.es"
        },
                {
          name: "Patrick Lünnemann",
          company: "Volkswagen Group",
          companyURL: "https://www.volkswagenag.com",
          w3cid: 95844
        }],
        edDraftURI: "https://github.com/w3c/automotive/blob/gh-pages/spec/VISSv2_Core.html",
        shortName: "VISSv2-CORE",
        localBiblio: {
          "SemVer": {
            title: "Semantic Versioning 2.0.0",
            href: "https://semver.org/spec/v2.0.0.html",
            status: "published",
            publisher: "Tom Preston-Werner"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document, the VISS version 2 CORE specification, describes the VISSv2 messaging layer. 
        The companion specifications for the VISSv2 transport protocols detail the mapping of the messaging layer to selected transports.
        The ontologies based on the VISSv2 core specification are defined in documents for each specific domain
        (e.g. navigation, media, vehicle data). 
      </p>
    </section>
    <section id='sotd'></section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This document describes the messaging API for VISSv2 protocol. 
        This includes the messaging layer and set of rules for structuring data.
        The separation between payload encoding (transport) and messaging API (core) improves adaptability. 
        Extending and describing multiple transport protocols becomes possible.
      </p>     
      <p>
        The messages are exchanged between a <a>server</a> implementation holding the representation of data 
        and a <a>client</a> using the data.
      </p>
      <p>
        The VISSv2 messaging layer uses a RESTful design for all methods exchanged via the interface (<a href="#interface"></a>).
      </p>
      <p>
        The VISSv2 data structuring rules (<a href="http://genivi.github.io/vehicle_signal_specification/">VSS Rule set</a>) are the same through all transport protocols.
        The basis for structuring data hold by a <a>server</a> is a tree.
      </p>
    </section>

    <section id="conformance"></section>
    <section id="terms">
      <h2>Terminology</h2>
      <p>The acronym 'VISSv2' is used to refer to this document, the second generation specification. 
      The acronym 'VSS' is used to refer to the 'Vehicle Signal Specification' which is defined by the GENIVI Alliance. 
      The term 'WebSocket' when used in this document, is as defined in the W3C WebSocket API and the WebSocket Protocol.
      </p>
    </section>

    <section id="data-model">
      <h2>Data Model</h2>
		<p>The service is intended for use with a tree-like logical taxonomy to represent the vehicle data. 
		An illustrative example of such a tree structure is shown in <a href="#fig-example-vss-tree">Figure 1</a>. 
		While it is meant to support conforming taxonomies it was created principally with the 
		<a href="https://github.com/GENIVI/vehicle_signal_specification">Vehicle Signal Specification</a> (VSS) in mind. 
		For more details, see the <a href="http://genivi.github.io/vehicle_signal_specification/">VSS documentation</a>.
		</p>
        <figure id="fig-example-vss-tree">
          <img src="images/vss-tree.jpg" alt="example-vss-tree">
          <figcaption> <span class="fig-title">Diagram showing an example VSS 2.0 tree.</span></figcaption>
        </figure>

      <section id="address">
        <h2>Addressing</h2>
        <p>Addressing of elements is done using URIs as defined in [[RFC3986]].</p>
        <blockquote><a>scheme</a>:<a>authority</a>/<a>path</a>?<a>query</a></blockquote>
        <p>The <dfn>scheme</dfn> describes the protocol to use to reach the addressed element.</p>
        <p>The <dfn>authority</dfn> describes where to reach the server holding and managing the data representation.
          Scheme and authority are defined within the protocol adaptation.</p>
        <p>The <dfn>path</dfn> consists of the slash delimited node names of the nodes traversed from the tree root to the tree leaf representing the data point. 
        E. g. the path expression from traversing the nodes Vehicle, Car, Engine, RPM would be "Vehicle/Car/Engine/RPM". The VSS data model uses a dot as delimiter, 
        the implementaion of this specification is expected to handle the necessary translation.</p>
        <p>The <a>query</a> contains further information related to the request, see <a href="#filter-request"></a>.
      </section>

        <section id="service-discovery">
          <h2>Service Discovery</h2>
          <p>The purpose of the data model is to provide a client with a description of the data that enables the client to make a request for desired vehicle data, 
          and interpret the response. In order to obtain that description, the client MAY request that the server returns the VSS tree content, 
          i. e. the metadata describing the accessible vehicle data. The client is able to request metadata from any point in the signal tree, 
          such that only the metadata for the nodes within the given branch of the tree is returned. For example, 
          only metadata for the chassis branch of the VSS tree is returned when the chassis path is specified. 
          If the path is set to the VSS root, the response contains the metadata for the entire tree. If the server is able to satisfy the request it SHALL return a Response message. 
          If an error occurs the server SHALL return an ErrorResponse message.<br>
          Some parts of the VSS tree may not be accessible to the Client due to restrictions defined in the <a href="#scope-list"></a>.<br>
          A service discovery request has the format of a read, where the path is appended with a query component, 
          see <a href="#capture-filter-operation"></a> for the details.<br>The key data components of these messagess are defined below:</p>
          <ul>
            <li>Request message parameters:</li>
            <ul>  
              <li>Path: The address to one or more nodes in the VSS tree, followed by the query component specifying the service discovery.</li>
            </ul>  
            <li>Response message parameters:</li>
            <ul>  
              <li>Metadata: The content of the VSS tree where the root is specified by the path.</li>
              <li>Timestamp: A timestamp associated with the request.</li>
            </ul>  
            <li>ErrorResponse message parameters: </li>
            <ul>  
              <li>Error: Information describing the error reason.</li>
              <li>Timestamp: A timestamp associated with the failed request.</li>
            </ul>  
          </ul>  
        </section>
    </section>

    <section id="interface">
      <h2>Interface</h2>
      <p>
        This chapter describes the different methods and its arguments that govern the communication between a <a>client</a> and the <a>server</a>.
      </p>

      <section id="methods">
        <h2>Methods</h2>
        <p>
          The transport protocols used to implement these methods MUST implement the Read and Update methods, and MAY implement the Subscribe, Unsubscribe, and Subscription methods. 
        </p>
        <section id="read">
          <h2><dfn>Read</dfn></h2>
          <p>Purpose: Get one or more values addressed by the given path.</p>
          <p>The client MAY have to obtain an <a>authorization</a> token before being able to access the values.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments, of which path is mandatory: 
          <ul>
            <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
            <li><a>filter</a> Additional information defining the requested data.</li>
            <li><a>authorization</a> The authorization token.</li>
          </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>value</a> The value(s) associated with the addressed VSS nodes.</li>
              <li><a>timestamp</a> The sample time of the value.</li>
            </ul>
          </p>
        </section>

        <section id="update">
          <h2><dfn>Update</dfn></h2>
          <p>Purpose: Provide altered value to the vehicle signal(s) addressed by the <a>path</a></p>
          <p>The client MAY have to obtain an authorization token before being able to update the vehicle signal(s).  
             If the server is able to satisfy the request it MUST return a <a>success response</a>. 
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments, of which path and value are mandatory: 
            <ul>
              <li><a>path</a> The path as defined in VSS to a single node in the VSS tree.</li>
              <li><a>value</a> The value by which the vehicle signal addressed by the path will be updated to.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>timestamp</a> The time for updating of the vehicle signals.</li>
            </ul>
          </p>
        </section>

        <section id="subscribe">
          <h2><dfn>Subscribe</dfn></h2>
          <p>Purpose: Get asynchronous messages containing the value(s) addressed by the path. The triggering rules for issuing the notification messages are set by the filter data.</p>
          <p>The client MAY have to obtain an authorization token before being able to subscribe to the vehicle signal(s).
             The server MUST issue a notification if a trigger rule is fulfilled.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.
             If an error occurs during the subscription period, the server SHOULD return an <a>error notification</a>.</p>
          <p>Arguments, of which path and filter are mandatory: 
            <ul>
              <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
              <li><a>filter</a> The rule set describing triggering criterias for issuance of asynchronous notification messages.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>subscriptionId</a> A handle identifying notification messages associated with the subscription.</li>
              <li><a>timestamp</a> The start time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section id="unsubscribe">
          <h2><dfn>Unsubscribe</dfn></h2>
          <p>Purpose: Termination of the subscription period started by a previous subscribe request.</p>
          <p>If the server is able to satisfy the request it MUST return a <a>success response</a>, and it MUST stop issuing notifications associated to the subscription handle.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments, of which subscriptionId is mandatory: 
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>timestamp</a> The stop time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section id="subscription">
          <h2><dfn>Subscription</dfn></h2>
          <p>Purpose: Asynchronous client notification according to the subscribe request trigger rules.</p>
          <p>The server MUST issue a notification message when a triggering rule associated with the subscription is met.
             If the server cannot fulfill the triggering rules it MUST issue an error notification and terminate the subscription. 
          </p>
          <p>Arguments: 
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>value</a> The value(s) associated with the node(s) being addressed in the subscribe request.</li>
              <li><a>timestamp</a> The time for the trigger activation.</li>
            </ul>
          </p>
        </section>
      </section>

      <section id="error-information">
        <h2>Error Information</h2>
        <p>The server MUST inform a client about errors ocurring in interactions between the two, whether it is in a synchronous <a>error response</a> to a request message, 
        or an asynchronous <a>error notification</a> message.
        </p>

        <section id="error-format">
          <h2>Error Format</h2>
          <p>The error information has three components - a <a>number</a>, a <a>reason</a>, and a <a>message</a>. The number MUST always be part of the error information, 
             while the reason and message components MAY be a part of it.
            <ul>
              <li><dfn data-dfn-type="dfn" id="dfn-error-number">number</dfn> See VISSv2:TRANSPORT, "Status code" chapter.</li>
              <li><dfn data-dfn-type="dfn" id="dfn-error-reason">reason</dfn> See VISSv2:TRANSPORT, "Status code" chapter.</li>
              <li><dfn data-dfn-type="dfn" id="dfn-error-message">message</dfn> See VISSv2:TRANSPORT, "Status code" chapter.</li>
            </ul>
          </p>
          </section>
      </section>

      <section id="security">
        <h2>Security</h2>
        <p>
        </p>
      </section>

      <section id="timestamp">
        <h2>Timestamps</h2>
        <p>
           Timestamps in transport payloads MUST conform to the ISO8601 standard, using the UTC format with a trailing Z. 
           Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired.
           The time and date format shall be as shown below, where the sub-second data and delimiter is optional.<br>
           YYYY-MM-DDTHH:MM:SS.ssssssZ<br>
           The exception to this is timestamps within tokens, which MUST conform to Unix time. 
        </p>
      </section>

        <section id="definitions">
          <h2>Definitions</h2>
	<p></p>

	<dl title="enum Defs" class="idl">
	  <dt><dfn data-dfn-type="dfn" id="dfn-client">client</dfn></dt>
	  <dd>An entity that works with data managed by a server.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-server">server</dfn></dt>
	  <dd>An entity that manages and offers access to data.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-success-response">success response</dfn></dt>
          <dd>The message being returned by the server to the client when no error is encountered. These are specific per request type</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-error-response">error response</dfn></dt>
	  <dd>The message being returned by the server to the client when an error is encountered. These have a common format for all request types</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-error-notification">error notification</dfn></dt>
	  <dd>The asynchronous message being returned by the server to the client when an error is encountered.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-value">value</dfn></dt>
	  <dd>The data that is associated with one or more VSS nodes. Regardless of its data type, a single data item is always represented as a string in message payloads.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-timestamp">timestamp</dfn></dt>
          <dd>A date and time representation. See chapter <a href="#timestamp"></a>.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn></dt>
	  <dd>Additional to help the server in the selection of data for the client.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-query">query</dfn></dt>
	  <dd>A filter may consist of multiple query expressions.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn></dt>
	  <dd>A token providing a verifiable proof that the client may be authorized access to the requested value(s).</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-subscription-id">subscriptionId</dfn></dt>
	  <dd>A handle identifying a subscription session.</dd>
	</dl>
      </section>
    </section>

	
    <section id="filter-request">
      <h2>Filter Request</h2>
	  <p>
	  Filtering is a mechanism to refine a client request, in order to more precisely control what is returned in a response. 
	  Filtering can be applied in read requests and in subscribe requests. 
	  A request where filtering is applied has the following structure
	  <ul>
	  <li>for the HTTP protocol:</li>
	  <ul>
	  <li>GET /vsspath?filter=json-expression</li>
	  </ul>
	  <li>for the Websocket protocol:</li>
	  <ul>
	  <li>{"action":"get", "path":"vsspath", "filter":"JSON-expression"}</li>
	  </ul>
	  </ul>
	  where<br>
	  <ul>
	  <li>Get is the transport protocol method,</li>
	  <li>vsspath is the path starting from the tree root,</li>
	  <li>filter is the key name for the filter expression,</li>
	  <li>json-expression contains the filter instructions.</li>
	  </ul>
	  </ul>
	  The JSON expression has the following format:<br>
	  <ul>
	  <li>[{"op-type":"x", "op-value":["y", "z",..], "op-extra":{}}, {optional-object}]</li>
	  </ul>
	  where<br>
	  <ul>
	  <li>op-type: the key name for the filter operation type, which can have one of the values:</li>
	  <ul>
	  <li>paths: the filtering is applied to the sub tree addressed by the vsspath,</li>
	  <li>history: the filtering is applied to the historic data that the server may have available,</li>
	  <li>capture: the filtering is applied to the data of the response to the request.</li>
	  </ul>
	  <li>op-value: the key name for the filter operation, which can have one of the values:</li>
	  <ul>
	  <li>paths:</li>
	  <ul>
	  <li>one or more relative paths.</li>
	  </ul>
	  <li>history:</li>
	  <ul>
	  <li>the time period from current time and backwards in time.</li>
	  </ul>
	  <li>capture:</li>
	  <ul>
	  <li>time-based: data captures are done with a fixed period time,</li>
	  <li>range: data captures are done when values are in the given range,</li>
	  <li>change: data capture is done when the value since last capture has changed more than a fixed value,</li>
	  <li>curve-logic: captured data are processed according to the curve logic algorithm before being sent to client.</li>
	  </ul>
	  </ul>
	  <li>op-extra: the key name for the optional configuration data that the filter operation requires. This data varies depending on the op-type and op-value, 
	  and is described in the following chapters.</li>
	  </ul>
	  In the JSON object, the key-value pairs "op-type" and "op-value" are mandatory, while "op-extra" is optional.
	  The JSON expression may consist of maximum one object with op-type "paths", plus maximum one object with op-type "capture", 
	  which are then logically combined as with an AND operator.<br>
	  The server SHALL support all combinations up to this maximum.<br>
	  The capture types (time-based, range, change, curve-logic) are only applicable for subscription requests. 
	  Subscription requests are only supported by the websocket transport protocol.<br>
	  The restriction on how many objects that can be combined is also set by the URL size restriction on 1k characters (*).<br>
	  (*) 1k is the "conservative limit, which should always be supported, a more liberal limit is 2k, which is supported in most cases.
	  </p> 

     <section id="paths-filter-operation">
        <h2>Paths Filter Operation</h2>
		<p>
		The paths filter operation is used when a single request is used to retrieve signal data from multiple data points in the VSS tree. 
		The vsspath shall point to the last node in the tree that is common for the relative paths in the filter op-value, that start off from this node. 
		If the end point of a path in the filter op-value is a branch, then all leaf nodes in the sub-tree below this branch are addressed.
		A path in the filter op-value may contain the wildcard character (*) as a representative for a path segment.<br>
		Every path element in an op-value array must address at least one node in the tree, or else an error response is returned.<br>
		If the path in the filter op-value ends with one or more wildcards, then only the leaf nodes with path segments matching the number of wildcards are addressed. 
		Different elements of the op-value array may address the same node, in which case it is the responsibility of the server to resolve this to a singleton in the notifications.<br>
		If the op-value contains a single path then it shall not be enclosed with JSON array brackets.<br>
		The op-extra key-value pair is not used in paths filter operations.<br>
		Examples can be found in the TRANSPORT specification.
		</p>
        </section>

     <section id="history-filter-operation">
        <h2>History Filter Operation</h2>
		<p>
		The server typically have access only to the latest, most fresh data point representing a signal. 
		However, it may for various reasons at least temporarily have access to also older data points. 
		A scenario where this could occur is when a vehicle temporarily loses its connectivity, 
		maybe because it enters into a tunnel. Assuming that the vehicle detects the loss of connectivity, it may then start to record data. 
		If recorded, this data may then be accessed using the history op-type. 
		The vehicle system makes its own decision whether to record any data, and for how long this data will be kept in storage. 
		The period goes from current time, excluding the current value, and backwards in time. 
		The number of data points in the response depends on the period size, and the sample frequency. 
		The latter can not be set by the client, so the client should have some understanding of its value to estimate the amount of data it may receive. 
		A request for historic data will return a Not found error if historic data is unavailable. 
		The period must conform to the [[ISO8601]] duration format, expressed with days, hour, minute, and second data, i. e. "op-value": "PdddDThhHmmMssS".
		The number of days shall be less than 999. Only a single period can be expressed.<br>
		The op-extra key-value pair is not used in history filter operations.<br>
		Examples can be found in the TRANSPORT specification.
		</p>
        </section>

     <section id="capture-filter-operation">
          <h2>Capture Filter Operation</h2>
		<p>
		The capture filter operation is used when the client want to restrict the amount of data that will be returned. 
		The op-extra key-value pair is used in capture filter operations, as described for the following capture types below.
		<ul>
		<li>time-based: the op-extra contains the period time X in between captures, {"period":"X"}.</li>
		<li>range: the op-extra contains the range boundary, and the logical operator, {"logic-op":"X", "boundary": "Y"}, where X is one of the supported logical operators (**), 
		and Y boundary of the range.
		The op-extra may be an array of two of these objects, combined through a logical AND to support expressions of a bounded range.</li>
		<li>change: the op-extra contains the the logical operator for comparison of previous and current values, {"logic-op":"X", "diff":"Y"}, 
		where X is one of the supported logical operators (**), and Y is the value of the required change.</li>
		<li>curve-logic: the op-extra contains the maximum error limit, and the buffer size, {"max-err": "X", "buf-size":"Y"}, 
		where X is a float value setting the max allowed error between any data sample and the simplified curve, 
		and Y is the number of buffer elements. Data is processed when the buffer becomes full, and the essential data points are returned as a time series per signal. 
		For more information on curve logic, please see "link-to-curve-logic-home".</li>
		</ul>
		(**)The supported logical operators are ["eq", "ne", "gt", "gte", "lt", "lte"], 
		where "eq" is "equal", "ne" is "not equal", "gt" is "greater than", "gte" is "greater than or equal", "lt" is "less than", "lte" is "less than or equal".<br>
		Examples can be found in the TRANSPORT specification.
               </p>
        </section>

     <section id="multiple-signals-request">
          <h2>Multiple Signals Request</h2>
	    <p>
	    The filtering operations may be used to address multiple tree nodes in one request. 
	    This may lead to specific issues in certain situations, as described below.
	    </p>

     <section id="error-handling">
          <h2>Error Handling</h2>
	    <p>
	    A request addressing multiple nodes may address both valid nodes, and invalid nodes. 
	    The latter case shall lead to a Not found error response message part that contains information about which node, or nodes, that are invalid. 
	    The error response shall not contain data from any of the validly addressed nodes.
	    </p>
     </section>

     <section id="error-handling">
          <h2>Response syntax</h2>
	    <p>
	    A response may contain multiple values, due to either that multiple nodes are addressed, or to that multiple values for one signal is returned.
	    These two reasons can be combined, leading to four different cases.
		<ul>
		<li>Request for a single value from a single node.</li>
		<li>Request for multiple values from a single node.</li>
		<li>Request for a single value from multiple nodes.</li>
		<li>Request for multiple values from multiple nodes.</li>
		</ul>
		The syntax to accomodate these four cases have a common structure where a data point ("dp") consists of one or more objects containing a "value" and a timestamp ("ts"), 
		and the complete aggregation ("data"), consists of one or more objects containing a "path" and a data point (dp"). The syntax of the four cases are shown below.
              <pre><code>
		“data”:{“path”:”X”, “dp”:{“value”:”Y”, “ts”:”Z”}}
		“data”:{“path”:”X”, “dp”: [{“value”:”Y1”, “ts”:”Z1”}, …, {“value”:”Yn”, “ts”:”Zn”}]}
		“data”:[{“path”:”X1”, “dp”:{“value”:”Y1”, “ts”:”Z1”}}, …, {“path”:”Xm”, “dp”:{“value”:”Ym”, “ts”:”Zm”}}]
		“data”:[{“path”:”X1”, “dp”:[{“value”:”Y11”, “ts”:”Z11”}, …, {“value”:”Y1n”, “ts”:”Z1n”}]}, …, {“path”:”Xm”, “dp”:[{“value”:”Ym1”, “ts”:”Zm1”}, …, {“value”:”Ymn”, “ts”:”Zmn”}]}]
              </code></pre>
               In the case of a request for multiple values from multiple nodes, the datapoint for different paths may contain single or multiple objects, 
               as the vehicle system may not have multiple values recorded for all requested signals.
	    </p>
     </section>

     <section id="subscription-notification-triggering">
          <h2>Subscription Notification Triggering</h2>
	    <p>
	    A subscription request must always contain a capture filter operation that describes the trigger event that leads to that the server dispatches an asynchronous notification message.
	    For the capture types "range" or "change", the triggering is dependent on the signal value. 
	    When the request addresses multiple signals, the triggering condition shall only be evaluated on one of the signals, which is the first signal in the op-value array of paths. 
	    The first path in the array must therefore not contain wildcards to address multiple signals. 
	    In this case one of the path addresses in the wildcard expression must be selected as the first array element, which can then be followed by the wildcard expression. 
	    The duplicate reference to one signal that this leads to shall be resolved by the server to a singleton in the notifications.
	    </p>
     </section>
     </section>
   </section>

   <section id="metadata-request">
     <h2>Metadata Request</h2>
	<p>
	Metadata requests are used when the client instead of the data associated to a VSS node wants to retrieve meta data associated to the VSS node.<br>
	A request for metadata has the following structure
	<ul>
	<li>for the HTTP protocol:</li>
	<ul>
	<li>GET /vsspath#metadata-type</li>
	</ul>
	<li>for the Websocket protocol:</li>
	<ul>
	<li>{"action":"get", "path":"vsspath", "metadata":"metadata-type"}</li>
	</ul>
	</ul>
	where
	<ul>
	<li>Get is the transport protocol method,</li>
	<li>vsspath is the VSS path,</li>
	<li>metadata-type describes the type of metadata that is requested, which can have one of the values:</li>
	<ul>
	<li>static-metadata: the entire set of metadata that is stored in the VSS tree for the addressed node(s). This is referred to as a signal discovery request.</li>
	<li>dynamic-metadata: current status of the addressed node(s). This is metadata that the server have access to that is not described in the VSS tree, 
	and its vlue may ary over time. </li>
	<li>Any metadata key name in the sets of static or dynamic metadata.</li>
	</ul>
	</ul>
	For the set of static metadata key names, see the <a href="https://github.com/GENIVI/vehicle_signal_specification">Vehicle Signal Specification</a>.<br><br>
	The set of dynamic metadata keynames are found in the list below. If a corresponding value to a key name is not present, the key-value pair is omitted in the response.
	<ul>
	<li>sample-rate: the native capture frequency in Hz that is used by the vehicle system.</li>
	<li>capture-filter: the capture filter operation that the vehicle system is configured for.</li>
	<li>availability: the current availability of a signal. The possible values are ["available", "temporary-unavailable", "permanently-unavailable"]. 
	The temporary-unavailable is returned when the signal is inaccessible due to the current vehicle state. 
	The permanently-unavailable is returned if the subsystem represented by the signal exists in the vehice, but is broken and requires repair.</li>
	<li>validate: the access control rule that is applied to the node and its sub-tree. 
	The server response shall conform to the inheritance rules, see the access control selection chapter.</li>
	<li>****Any more?****</li>
	</ul>
	Multiple key names can be combined in the same request by concatenating them with a plus sign (+) as delimiter.<br>
	A metadata request can be combined with a paths filter operation to address multiple nodes, but not with a capture filter operation.<br>
	The response is a JSON formatted object with corresponding key-value pairs per addressed node.<br>
	Examples can be found in the TRANSPORT specification.
	</p>
    </section>
 
    <section id="access-control-model">
      <h2>Access Control Model</h2>
      <p>
      Access control MUST be supported. However, in this chapter only the sections that describe the interactions between the Client and the VISSv2 server are normative.
      </p>

      <section id="architecture">
        <h2>Architecture</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The VISSv2 access control model is inspired by the concepts of OAuth2.0 [[RFC6749]], but some deviations exist as is described in the following chapters.<br><br>
        Four actors are defined:<br>
        <b>Client</b><br>
        An application making protected and authorized resource requests on behalf of its user.<br>
        <b>Access Grant server</b><br>
        The server issuing the Access Grant credential after successfully authenticating the Client.<br>
        <b>Access Token server</b><br>
        The server issuing the Access Token to the Client after successfully validating the request and obtaining authorization.<br>
        <b>VISSv2 server</b><br>
        The server hosting the protected resources, capable of accepting and responding to protected resource requests using Access Tokens.<br><br>
        The abstract protocol flow illustrated in the figure below describes the interaction between the four actors.<br>
        <figure id="fig-oauth2.0-flow">
          <img src="images/VISSv2-abstract-flow.jpg" alt="VISSv2 abstract protocol flow.">
          <figcaption> <span class="fig-title">The abstract protocol flow.</span></figcaption>
        </figure>
        Besides the four actors directly involved in the abstract flow, there are two more actors.<br>
        <b>Resource owner</b><br>
        This is typically the driver of the vehicle, who may be asked for consent before access is granted.<br>
        <b>Ecosystem manager</b><br>
        The entity managing the access control ecosystem. It controls the Policy documents, and manages the PKI ecosystem that the other actors may utilize.<br><br>
        The abstract protocol flow is implemented by two different flows, as will be described in the following chapters.<br>
        The process to obtain the credentials needed for Client authentication is out-of-scope, as well as the installation procedures for the applications.
        </p>
      </section>

      <section id="access-control-flows">
        <h2>Protocol Flows</h2>
        <p>
        <em>This section is non-normative.</em><br>
        Two different flows are described. Which flow to use depends on the capabilities of the Client.<br>If a Client is able to run public key cryptographic primitives, 
        i.e. key pair generation and signatures, and has access to some kind of trusted execution environment where private keys are protected from the regular execution environment, 
        then it can use the Long term flow. Clients that do not have access to these capabilities, or do not want to use them, must select the Short term flow.<br>
        The advantage of using the Long term flow is that the Client can be trusted with longer expiry times of Access Grant tokens. 
        In the Short term flow the Client must due to a shorter expiry time contact the Access Grant Server (AGS) more often to obtain a new Access Grant token.<br>
        A Client selects the type of flow by either submitting a public key in the AG message, or not. The latter leading to an Short term flow.
        </p>
      </section>

      <section id="protocol-messages">
        <h2>Protocol Messages</h2>
        <em>This section is non-normative.</em><br>
        This chapter describes the payloads of the messages used in the protocol flow.

        <section id="authorization-grant-request">
          <h2>Access Grant Request</h2>
          <p>
          The request shall contain the first three parameters below, the last is optional:
          <ul>
            <li>VIN: The vehicle identification number. This may be a pseudo-VIN, or any other identity that uniquely links to the vehicle in the access control ecosystem.</li>
            <li>Context: The context associated to the Client. The context consists of a triplet of roles for User, App permissions, and Device characteristics.</li>
            <li>Proof: A proof mechanism that is used by the Client to attest its context to the AG server. This is indeed a composed proof for the User role, App permissions, 
            and Device characteristics.</li>
            <li>Public key: If this parameter is present, the client will receive a Long Term Access Grant Token in return.</li>
          </ul> 
          </p>
          <p>
            Depending on the kind of Proofs included in the request, the client and the server may need to run an interactive protocol to verify them. 
            The protocol may involve also third parties, such as the Ecosystem manager or the resource owner. The protocol is out of scope for this specification.
          </p>
        </section>

<section id="authorization-grant-response">
          <h2>Access Grant Response</h2>
          <p>
          The response shall contain the parameter below:
          <ul>
            <li>AG token: A signed token with claims needed for the validation of the Client request.</li>
          </ul> 
          The response for a successful access grant request is a Short or Long term Access Grant token, depending on the input in the request message. 
          The only difference between both kind of tokens is that Long term Access Grant token would include the public key used in the request.
          <br>
          The Access Grant token is a digitally signed document issued by the AG Server including all relevant information needed to issue Access Tokens.
        </p>
        <p>
          An error response shall contain the parameter:
          <ul>
            <li>Error code: The error code shall be informative in order for the Client to understand what it needs to correct to become successful.</li>
          </ul> 
        </p>

        </section>

       

        <section id="access-token-request">
          <h2>Access Token Request</h2>
          <p>
          The request shall contain at least these two parameters below:
          <ul>
            <li>AG token: A signed token with claims needed for the validation of the Client request.</li>
            <li>Purpose: The Purpose shall be one of the short text entries from the <a href="#purpose-list"></a>.</li>
          </ul> 
            Short term Access Grant tokens can be used as direct input to the Access Token server, but Long term AG tokens should be accompanied by a Proof of Possession (PoP) 
            for the private key corresponding to the public key included in the token, see chapter <a href="#proof-of-possession"></a>.
          </p>
          <p>
            The Access Token server acts as a Policy Enforcement Point, making decisions on whether to grant access to the protected resource based on the provided AG Token and Purpose.
          </p>

        </section>

        <section id="access-token-response">
          <h2>Access Token Response</h2>
          <p>
          A successful response shall contain the parameter:
          <ul>
            <li>Access token: The Access token to be used in Client requests to the VISSv2 server for Protected Resources.</li>
          </ul> 
          An error response shall contain the parameter:
          <ul>
            <li>Error code: The error code shall be informative in order for the Client to understand what it needs to correct to become successful.</li>
          </ul> 
          </p>
        </section>

        <section id="protected-resource-request">
          <h2>Protected Resource Request</h2>
          <p>
          This is the VISSv2 request including an Access token that is described in general in the <a href="#interface"></a> chapter, 
          and for different transport protocols in the VISSv2 CORE document.
          </p>
        </section>

        <section id="protected-resource-response">
          <h2>Protected Resource Response</h2>
          <p>
          This is the VISSv2 response that is described in general in the <a href="#interface"></a> chapter, and for different transport protocols in the VISSv2 CORE document.
          </p>
        </section>
      </section>

      <section id="actors">
        <h2>Actors</h2>

      <section id="client">
        <h2>Client</h2>
        <p>
        <em>This section is non-normative.</em><br>
          The Client is an abstract representation of three sub-actors: 
          <ul>
            <li>The Device. It is in charge of running the Apps that make requests to the VISSv2 server</li>
            <li>The App. It runs requests on behalf of the User.</li>
            <li>The User. It delegates access rights to the App.</li>
          </ul> 
          All the information regarding the client is encoded in the Context of the request.
        </p>
      </section>

      <section id="access-grant-server">
        <h2>Access Grant Server</h2>
        <p>
        <em>This section is non-normative.</em><br>
          The Access Grant server (AGS) is in charge of producing Access Grants to Clients.<br>
          Depending on the capabilities of the Client, the specification supports two types of Access Grant Tokens: Short term and Long term AG Tokens.<br>
          Long term Access Grant Tokens, are supported for those Clients able to run public key cryptographic primitives, i.e. key pair generation and signatures, 
          and is the recommended choice for Clients with access to a trusted execution environment where private keys are protected from the regular execution environment. 
          The specification also supports Short term Access Grant Tokens that require no extra capabilities in the client, 
          but due to its shorter expiry time it forces the client to contact the AGS more often before Access Token Server (ATS) requests for an Access Token.<br>
          The Client request shall contain the following:
          <ul>
            <li>A VIN.</li>
            <li>A Context.</li>
            <li>A set of Proofs.</li>
          </ul> 
          If the Client needs a Long term AG token, then the request shall also contain:
          <ul>
            <li>A public key.</li>
          </ul> 
          The Vehicle identification number shall be for the vehicle that the Client wants to access.<br>
          The Context contains all relevant information from the client, i.e. for each of the three sub-actors that the Client represents.<br>
          The Proofs are to be used for verifying the Context of the Client.<br>
          The public key shall be generated by the Client, and the associated private key must be under control of the Client.<br><br>
        The main responsibilities of the Access Grant server are:
          <ul>
            <li>To verify the <a href="#client-context"></a>, and assess that their respective role request can be granted.</li>
            <li>To check that the vehicle represented by the VIN belong to this Ecosystem, and is accessible.</li>
            <li>To create an Access Grant token.</li>
          </ul>
          The proofs may include certificates from a Certificate Authority known by the AG server. For example, 
          users might authenticate themselves using X.509 identity certificates and roles might be issued using attribute certificates. In those cases, as part of the authentication protocol, 
          the AG server shall also validate the certificates signatures.<br>
          The AG server may contact the Ecosystem manager for checking the VIN.<br>
          The Access Grant token generation is defined in the corresponding chapter.
        </p>
          </p>
        </section>

       
      <section id="access-token-server">
        <h2>Access Token Server</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Client shall after a successful interaction with the AG server request an Access token from the Access Token server. 
        The Client request shall contain at least these two parameters below.
          <ul>
            <li>Access Grant token.</li>
            <li>Purpose.</li>
          </ul>
        For Long term Access Grant tokens, i.e. those including a public key, the Client must also include a PoP, for the corresponding private key, in the request.<br>
        The Purpose must be supported by the Ecosystem manager, and thus be on the Purpose list, see the chapter <a href="#purpose-list"></a>. 
        The Purpose list associates a set of accessible signals to the Purpose, thus realizing the principle of least privilege.<br>
        The main responsibilities of the Access Token server are:
          <ul>
            <li>To validate the Access Grant token.</li>
            <li>To validate that the Client context provides permission for the requested Purpose.</li>
            <li>To create an Access Token.</li>
          </ul>
        The validation of the AG token consists of at least the following:
          <ul>
            <li>Signature validation.</li>
            <li>Expiry time check.</li>
          </ul>
        Additionally, for Long term Access Grant tokens, the Access Token server needs to verify the PoP using the public key contained in the token, 
        see chapter <a href="#proof-of-possession"></a>.<br>
        The AG token signature validation is done with the AG server public key. 
        <br>
        To allow for some time synchronization inaccuracy and minor network latency, expiry times should be set to include potential modest margin of error, possibly as long as tens of seconds.<br>
        If the Client context as declared in the AG token does not match in the set of allowed roles for the requested Purpose in the Purpose list document, 
        then the client request for an Access token must be denied.<br>
        The Access token to be generated is defined in the chapter <a href="#access-token"></a>.
        </p>
      </section>

      <section id="VISSv2-access-control-server">
        <h2>VISSv2 Access Control Server</h2>
        <p>
        The VISSv2 server MUST support validation of Access tokens.
        This includes validation of at least the following:
          <ul>
            <li>Token signature.</li>
            <li>Token expiry time.</li>
            <li>Token scope.</li>
            <li>Token access mode.</li>
          </ul>
          If any of the mentioned validations above fail, the server MUST reject the access request.<br>
          Token signature validation may be delegated to the AT server, if a secure communication link can be established.
          If not delegated, then a preprovisioned common secret may be shared with the AT server, or other PKI based solutions may be used.<br>
          The VISSv2 server SHALL have access to a secure system time, that cannot be modified by actors without system acknowledged credentials. 
          Time validation may allow for a time synchronization inaccuracy in the range of tens of seconds.<br>
          A successful scope validation requires that all the nodes addressed by the path in the request MUST 
          be matched by the paths associated with the Purpose in the scope claim of the Access token.<br>
          Validation of the Device and App roles may involve MAC address checks, message round-trip measurements, etc.<br>
          The access mode validation MUST have the outcome shown in the table below, 
          when comparing the type of the Client request with the access control mode in the <a href="#purpose-list"></a> that is associated to the scope claim in the Access token.
          If the Client request contains several signals, and one fails the validation, then the entire request MUST be rejected.<br><br>
          <table class="simple">
          <thead>
            <tr><th>Validation</th><th>Read-only</th><th>Read-write</th></tr>
          </thead>
          <tbody>
            <tr>
              <th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-getrequest">get<br>set<br>subscribe</dfn></th>
            </tr>
            <tr><td>Ok</td><td>Ok</td></tr>
            <tr><td>Nok</td><td>Ok</td></tr>  
            <tr><td>Ok</td><td>Ok</td></tr>  
          </tbody>
          </table>
        </p>
        <p>
          The Access Token need to be refreshed periodically, which is controlled by the expiry time. If the AG token that the Client used to obtain the now expired Access token is not expired, 
          then the Client can revisit the AT server with this AG token to obtain a new Access token.<br>
          If the AG token is expired, then the Client must obtain a new AG token first, before revisiting the AT server.<br>
          For Client requests that are not granted due to access control, the VISSv2 server MUST return one of the error codes shown in the table below.<br>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Message</th>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>missing_token</td>
	    <td>One or more of the requested signals are access controlled, an access token must be included in the request.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>invalid_token</td>
	    <td>A fresh access token must be obtained.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>insufficient_priviledges</td>
	    <td>The priviledges represented by the access token are not sufficient.</td>
	  </tr>
	  </tbody>
	</table>
        </p>
      </section>

      <section id="resource-owner">
        <h2>Resource Owner</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Resource owner is typically the owner and/or driver of the vehicle. If Consent is required for granting access to the protected resource, 
        then it should be directed to the Resource owner. The process for this is out of scope for this specification.
        </p>
      </section>

      <section id="ecosystem-manager">
        <h2>Ecosystem Manager</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Ecosystem manager is the entity responsible for the functionality of the access control system. This typically includes the management of the Access Grant server, 
        and the Access Token server, the Policy documents, and that there is a PKI domain for the other actors to utilize. 
        </p>
      </section>
      </section>

      <section id="credentials">
        <h2>Credentials</h2>
        <p>
        </p>

        <section id="client-authentication">
          <h2>Client Authentication</h2>
          <p>
          <em>This section is non-normative.</em><br>
          The three Client sub-actors must provide authentication credentials to the AG server. 
          This may be certificates that the sub-actors have obtained from a Certificate Authority that is known by the AG server. 
          The interactions related to this are out of scope.
          </p>
        </section>

        <section id="authorization-grant-token">
          <h2>Access Grant Token</h2>
          <p>
          <em>This section is non-normative.</em>
          </p>

          <section id="ags-signed-agtoken">
            <h2>Short Term AG Token</h2>
            <p>
          The Short term Access Grant token shall have the following claims in header and payload.<br>
	  <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>          
	  {
            "alg": "ES256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "aud": "w3.org/VISSv2",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
	  </pre>
	  Algorithm (alg) shall be set to a valid RSA or ECDSA algorithms according to [[RFC7518]].<br>
	  Type (typ) shall be set to "JWT".<br>
	  VIN (vin) shall be set to the vehicle identity provided by the Client.<br>
          Issued at (iat) shall be set to the time of token issuance, in Unix time.<br>
          Expiry (exp) shall be set to the time when the token expires, in Unix time.<br>
          Client context (clx) shall be set to the role triplet the client has been assigned. The delimiter separating the roles is a plus sign (+).<br>
          Audience (aud) shall be set to the URL "w3.org/VISSv2".<br>
          JWT ID (jti) shall be set to a UUID that is unique within the domain controlled by the Ecosystem manager.
            </p>
          </section>

          <section id="client-signed-agtoken">
            <h2>Long Term AG Token</h2>
            <p>
          The Long term Access Grant token shall have the following claims in header and payload.<br>
	  <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>          
	  {
            "alg": "ES256",
            "typ": "JWT"
          },
          {
            "vin": "vehicle-id",
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "pub": client_pub_key,
            "aud": "w3.org/VISSv2",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
	  </pre>
	  Algorithm (alg) shall be set to a valid RSA or ECDSA algorithms according to [[RFC7518]].<br>
	  Type (typ) shall be set to "JWT".<br>
	  VIN (vin) shall be set to the vehicle identity provided by the Client.<br>
          Issued at (iat) shall be set to the time of token issuance, in Unix time.<br>
          Expiry (exp) shall be set to the time when the token expires, in Unix time.<br>
          Client context (clx) shall be set to the role triplet the client has been assigned. The delimiter separating the roles is a plus sign (+).<br>
          Public key (pub) shall be set to the public key that the Client provided in the AG request, using the JSON Web Key (JWK) data structure [[RFC7517]].<br>
          Audience (aud) shall be set to the URL "w3.org/VISSv2".<br>
          JWT ID (jti) shall be set to a UUID that is unique within the domain controlled by the Ecosystem manager.
            </p>
          </section>
        </section>

        <section id="access-token">
          <h2>Access Token</h2>
          <p>
          The Access token SHALL have the following claims in header and payload.<br>
	  <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>          
	  {
            "alg": "HS256",
            "typ": "JWT"
          },
          {
            "iat": 1609452095,
            "exp": 1609459199,
            "scp": "PurposeX",
            "clx": "user+app+dev",
            "aud": "w3.org/VISSv2",
            "jti": "5967e93f-40f9-5f39-893e-cc0da890db2e"
          }
	  </pre>
	  Algorithm (alg) shall be set to any valid algorithms according to [[RFC7518]].<br>
	  Type (typ) shall be set to "JWT".<br>
          Issued at (iat) shall be set to the time of token issuance, in Unix time.<br>
          Expiry (exp) shall be set to the time when the token expires, in Unix time.<br>
          Scope (scp) shall be set to the Purpose short name, which logically links to the signal scope as defined in the <a href="#purpose-list"></a>.<br>
          Client context (clx) shall be set to the role triplet the client has been assigned. The delimiter separating the roles is a plus sign (+).<br>
          Audience (aud) shall be set to the URL "w3.org/VISSv2".<br>
          JWT ID (jti) shall be set to a UUID that is unique within the domain controlled by the Ecosystem manager.
          </p>
        </section>

        <section id="proof-of-possession">
          <h2>Proof of Possession</h2>
          <em>This section is non-normative.</em><br>

          <p>
            Long term Access Grant tokens need to be accompanied by a Proof of Possession (PoP) for the private key corresponding to the public key included in the Access Grant token. 
            This requirement enables a longer validity for this kind of tokens, ranging from a few days to a even a year.
            By adding the PoP, we prevent an eavesdropper to reuse an Access Token request, impersonating the client. Without a PoP, the longer the validity of an Access Grant token, 
            the higher the risk an attacker could intercept and reuse it.
            PoP for JWT are defined in [[RFC7800]], but in essence, a PoP enables the requester to proof to the server that it has access to a private key, without disclosing it. 
            Traditionally that would require the server to create a random challenge, or nonce, and ask the client to sign it with its private key. Along with the public key, 
            the server would be able to verify the PoP.
            This scheme would require an extra step in the protocols, where the client ask for the nonce.
          </p><p>
            In order to avoid this extra step, the client can generate the nonce itself. The server would need to check that nonces are not reused. 
            Although logging previous nonces at the server side would work for small environments, we propose the use of an incremental nonce in the form of a timestamp. 
            One of the drawbacks of this proposal is that the server has no means to check whether the PoP has been precomputed or not. 
            However, this is irrelevant from the eavesdropper point of view.
          </p><p>
            In case freshness of the PoP was a critical requirement, we could use a public source of randomness to obtain the nonce, 
            e.g. <a href="https://www.cloudflare.com/leagueofentropy/">Leage of Entropy</a> or 
            <a href="https://csrc.nist.gov/projects/interoperable-randomness-beacons">Interoperable Randomness Beacons</a>. 
            That would provide the server a mean to check freshness of the PoP but on the other hand, 
            it would require the client to access the public source of randomness every time it needs to create a PoP which is against the main designs goal of the Long term Access Token grant.
              </li>
            </ul>
          </p>
        </section>
      </section>

      <section id="client-context">
        <h2>Client Context</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Client actor described in the <a href="#client"></a> chapter is characterized by three subactors:
          <ul>
            <li>The user of the application.</li>
            <li>The application.</li>
            <li>The device.</li>
          </ul>
          Each of these subactors is in turn characterized by a role, 
          building on the concept of a <a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role Based Access Control (RBAC) model</a>. 
          The set of these three roles is called the Client context.<br>
          VISSv2 specifies a rudimentary list of roles for each subactor, it is expected that these lists are augmented by the Ecosystem manager, hopefully in a cooperative effort.<br>
          Using an RBAC model provides the following main purposes in the VISSv2 access control model:
          <ul>
            <li>Input to the AG server in the Client authentication process.</li>
            <li>Input to the AT server in the Purpose validation.</li>
          </ul>
        The AG server must in the authentication process of the client possibly separately authenticate each of the three subactors. 
        For the AG server to decide on which authentication method to use per subactor can be quite complex, but may be somewhat eased by the Client request for roles for each subactor.<br>
        Following the principle of least priviledge, a Client should not have access to more vehicle signals than necessary. 
        This is achieved by the Purpose document described in the <a href="#purpose-list"></a> chapter, that assigns only the for the Purpose relevant signals to the Client. 
        </p>

        <section id="user-roles">
          <h2>User Roles</h2>
          <p>
          VISSv2 specifies the following minimum set of roles for users:
          <ul>
            <li>OEM</li>
            <li>Dealer</li>
            <li>Independent</li>
            <li>Owner</li>
            <li>Driver</li>
            <li>Passenger</li>
          </ul>
          An OEM user is anyone representing the vehicle brand.<br>
          A Dealer user is anyone representing a normally OEM affiliated organisation that provice sale and workshop services for the vehicle.<br>
          An Independent user is anyone representing a normally OEM independent organisation that provide after-market services for the vehicle.<br>
          An Owner user is anyone representing the organisation owning the vehicle.<br>
          A Driver user is anyone driving the vehicle.<br>
          A Passenger user is anyone travelling in the vehicle, but not being the Driver.<br>
          </p>
        </section>

        <section id="application-roles">
          <h2>Application Roles</h2>
          <p>
          VISSv2 specifies the following minimum set of roles for applications:
          <ul>
            <li>OEM</li>
            <li>Third party</li>
          </ul>
          An OEM application role is used for applications that are pre-installed in the vehicle by the OEM, or later OEM-provisioned to the vehicle.<br>
          A Third party application role is used for applications that are "certified" for vehicle deployment, but developed by a third party.<br>
          </p>
        </section>

        <section id="device-roles">
          <h2>Device Roles</h2>
          <p>
          VISSv2 specifies the following minimum set of roles for devices:
          <ul>
            <li>Vehicle</li>
            <li>Nomadic</li>
            <li>Cloud</li>
          </ul>
          A Vehicle role is used for applications that are deployed in-vehicle, in e. g. the center stack ECU.<br>
          A Nomadic role is used for applications that are deployed in a User's mobile phone, laptop, etc, that uses short range radio communication like Bluetooth, or WiFi.<br>
          A Cloud role is used for applications that are deployed in off-vehicle devices, and uses a long range radio communication like cellular in the connection to the vehicle.<br>
          </p>
        </section>
      </section>

      <section id="policy-documents">
        <h2>Policy Documents</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Policy documents are typically owned and created by the Ecosystem manager. They need to be handled securely to protect their integrity. 
        The Ecosystem manager shall securely provision them to the Access Token servers in the access control ecosystem.
        </p>

          <section id="purpose-list">
            <h2>Purpose List</h2>
            <p>
        A Client shall provide a Purpose as input to a request for an Access token. A list of supported purposes needs to exist for a client to select from. 
        The Ecosystem manager shall therefore provide means for Clients to survey the list to find a Purpose that fits its use case.<br>
        Each entry in the list contains a short description of the purpose, which is what the Client shall provide as input to its request for an Access token. 
        There is also a long description, which may be used in the dialogue for consent, if needed. Then there is a list of the Client contexts, i. e. the sub-actor role triplet, 
        that can be granted this access, and last there is a list of  the signals that the client is given access to for this purpose, 
        with the allowed access mode. The list shall use a JSON format as shown in the example below.
        <pre><code>
        {"purposes":
            [{"short": "fuel-status", 
            "long": "Fuel level and remaining range.", 
            "contexts":[{"user":"Independent","app":["OEM", "Third party"], "device":"Cloud"}, {"user":"Owner", "app":"Third party", "device":"Nomadic"}, {"user":"Driver", "app":"OEM", "device":"Vehicle"}], 
            "signal_access":
                [{"path": "Vehicle.Powertrain.EnergyStorage.FuelSystem.Level", "access_mode": "read-only"}, 
                {"path": "Vehicle.Powertrain.EnergyStorage.FuelSystem.Range", "access_mode": "read-only"}] 
            }, 
            {}] 
        }
        </code></pre>
        The Purpose list shall be securely provisioned to the AT server. The protocol for this is out-of-scope. 
        The AT server must reject all requests for Access tokens if it is not in possession of a Purpose list.
            </p>
          </section>

          <section id="scope-list">
            <h2>Scope List</h2>
            <p>
            The Scope list contains a list of the VSS tree nodes for which access shall be prohibited, per Client context. 
            This prohibition is regardless of whether the Client has a valid Access token or not.<br>
            The Scope list can also be used to limit the node metadata that is returned on a Client service discovery request.<br>
            Each entry in the list contains a list of paths to nodes that should be excluded, and a list of the Client contexts, i. e. the sub-actor role triplet, 
            for which this exclusion should be made.<br>
            The Scope list may contain an entry for a context with all three Roles set to "Undefined". 
            The no-access scope of this entry shall then be used for signal discovery requests where no token is included.<br>
            The list shall use a JSON format as shown in the example below.
        <pre><code>
        {"scope":
            [{"contexts":[ { "user":["Driver", "Passenger"], "app":"Third party", "device":"Vehicle"}, { } ], 
            "no_access":
                ["Vehicle.Drivetrain.Transmission.Speed", 
                "Vehicle.Cabin.Infotainment.Navigation.CurrentLocation.Latitude", 
                "Vehicle.Cabin.Infotainment.Navigation.CurrentLocation.Longitude"]
            }, 
            {}] 
        }
        </code></pre>
        The Scope list shall be securely provisioned to the AT server. The protocol for this is out-of-scope.
        The AT server shall not restrict the scope for any Client context if it is not in possession of a Scope list.
            </p>
          </section>
      </section>

      <section id="access-control-selection">
        <h2>Access Control Selection</h2>
        <p>
        <em>This section is non-normative.</em><br>
        This chapter describes a complementary functionality to the access control model, the ability to apply it selectively to parts of the tree. 
        It can be used in cases where not all nodes of the tree are believed to require access control, 
        or read-only is sufficient instead of read-write access control for certain nodes.<br>
        This functionality requires that the Access token specifies whether the access granted to the Client to a signal is read-only, or read-write.
        It also requires that the metadata for the node in the VSS tree contains data specifying whether the access control verification should be carried out only for write request, 
        or for both read and write requests.<br>
        The former requirement is realized as described in earlier chapters by that the Access token scope claim links to a Purpose entry in the <a href="#purpose-list"></a> 
        where the signals and their respective access mode are found.<br>
        The latter requirement is realized by adding to nodes in the VSS tree the key-value pair "validate":'access-control-mode', 
        where 'access-control-mode' is either the string "write-only", or "read-write".<br>
        <figure id="fig-access-control-selection">
          <img src="images/access-control-selection.jpg" alt="Access control selection tagging.">
          <figcaption> <span class="fig-title">Access control selection tagging.</span></figcaption>
        </figure>
        The figure above shows an example where both read and write requests to the three leftmost leaf nodes will be access controlled, 
        while the two rightmost leaf nodes only will be access controlled for write requests. 
        An inheritance rule leads to that any nodes below a tagged node are assigned the same access control, if they are untagged.<br>
        This metadata is not likely to be applied to the standardised VSS tree, as different implementers of this standard may have different views on which nodes to apply it to. 
        Instead it is anticipated that it is applied at a "deployment" stage, possibly using the VSS layering concept.<br>
        The inheritance model, which says that if access-control-mode data is added to a node, then all nodes in the subtree for which this node is the root inherits the setting, 
        unless there is access-control-mode data added to any node in this subtree, makes possible a reduction of the number of nodes this metadata have to be added to.<br>
        This allows for example an entire VSS tree to be assigned an access-control-mode by merely applying it in the root of the tree.<br>
        The figure below shows an overview of the access control selection model, 
        and a table showing the required access control tagging of a node for the VISSv2 server to grant the requested access. 
        <figure id="fig-access-control-selection-model">
          <img src="images/access-control-selection-model.jpg" alt="Access control selection model.">
          <figcaption> <span class="fig-title">Access control selection model.</span></figcaption>
        </figure>
        If the VSS tree used by a VISSv2 server contains access control selection tags, then the server MUST support their usage as described in this chapter.<br>
        If it is not used, then a server may implement access control for the entire tree.<br>
        </p>
      </section>
    </section>

    <section id="tof" class="appendix"></section>
  </body>
</html>
