<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>VISS version 2-Transport</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        group: "auto",
        github: "https://github.com/w3c/automotive",	
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Geotab (formerly Volvo Cars)",
          companyURL: "https://www.geotab.com",
          w3cid: 103092	  
        },
        {
          name: "이원석(Wonsuk Lee)", company: "한국전자통신연구원(ETRI)",
          url: "mailto:wonsuk.lee@etri.re.kr",
	  companyURL: "https://etri.re.kr/eng/main/main.etri",
	  w3cid: 34457
        }],
	formerEditors: [{
          name: "Ulf Bjorkengren",
          company: "Volvo Cars",
          companyURL: "https://www.volvo.com",
          w3cid: 103092	  
        },
	{
          name: "Patrick Lünnemann",
          company: "Volkswagen Group",
          companyURL: "https://www.volkswagenag.com",
          w3cid: 95844
        }],	  
        edDraftURI: "https://github.com/w3c/automotive/blob/gh-pages/spec/VISSv2_Transport.html",
        shortName: "VISSv2-TRANSPORT"
      };
    </script>
    <style>
      table.parameters, table.exceptions {
          border-spacing: 0;
          border-collapse:    collapse;
          margin: 0.5em 0;
          width:  100%;
      }
      table.parameters { border-bottom:  1px solid #90b8de; }
      table.exceptions { border-bottom:  1px solid #deb890; }

      .parameters th, .exceptions th {
          color:  inherit;
          padding:    3px 5px;
          text-align: left;
          font-weight:    normal;
      }
      .parameters th { color: #fff; background: #005a9c; }
      .exceptions th { background: #deb890; }

      .parameters td, .exceptions td {
          padding:    3px 10px;
          border-top: 1px solid #ddd;
          vertical-align: top;
      }

      .parameters tr:first-child td, .exceptions tr:first-child td {
          border-top: none;
      }

      .parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
          width:  100px;
      }

      .parameters td.prmType {
          width:  120px;
      }

      table.exceptions table {
          border-spacing: 0;
          border-collapse:    collapse;
          width:  100%;
      }

      .simple {
        width:100%;
      }

      thead th{
        border-bottom: 1px solid black;
      }

      .simple tbody th{
        width:33%;
        background: white;
        color: black;        
      }
      pre { white-space: pre-wrap;}
  </style>    
  </head>
  <body>
    <section id='abstract'>
      <p>The Vehicle Information Service Specification (VISS) is a
      service for accessing vehicle information, signals from sensors
      on control units within a vehicle's network. It exposes this
      information using a hierarchical tree like taxonomy defined in
      GENIVI Vehicle Signal Specification (VSS). The service provides
      this information in JSON format. The service may reside in the
      vehicle for applications needing to analyse a high volume of
      realtime data or on servers in the internet with information
      already brought off the vehicle.
      </p>

      <p>This specification describes a second version of VISS which
      has been implemented and deployed on production vehicles. It
      adds major new capabilities and improvements to the earlier
      version. The first version of VISS only supported WebSocket as a
      transport protocol, the second version is generalized to work
      across different protocols as some are better suited for
      different use cases. HTTP is now supported with additional
      protocols used within the automotive industry being evaluated
      for inclusion. Subscription capabilities have been improved and
      access control has been added.
      </p>
      
      <p>
        There are two parts to this specification, Core and Transport. This document, the VISS version 2 TRANSPORT specification, 
        describes the VISSv2 transport protocols, and the mapping of the message layer on these transports. 
        The companion specification VISSv2 CORE describes the messaging layer.
      </p>
    </section>
    <section id='sotd'></section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>This document describes the transport bindings of the Vehicle Information Service Specification, version 2. 
      The split between transport bindings and messaging layer specifications improves readability and simplifies 
      extending the specification to further transports in the future. 
      This specification supports multiple transport bindings, the secure versions of HTTP, WebSocket, and MQTT.
      </p>
    </section>

    <section id="conformance"></section>

    <section id="terminology">
      <h2>Terminology</h2>
      <p>The acronym 'VISSv2' is used to refer to this document, the VISS version 2 specification.
         The acronym 'VSS' is used to refer to the 'Vehicle Signal Specification' which is defined by the GENIVI Alliance.
         The term 'WebSocket' when used in this document, is as defined in the W3C WebSocket API and the WebSocket Protocol.
      </p>
    </section>

    <section id="transport-common-defs">
      <h2>Transport Common Definitions</h2>
      <p>This chapter defines features that SHALL be common for all transport protocols.</p>

      <section id="status-codes">
        <h2>Status Codes</h2>
	<p>The server implementation <em class="rfc2119" title="SHALL">SHALL</em> support the error numbers listed in the table below, 
	with the associated reason and message fields, for all supported transport protocols.</p>
        <p>The client <em class="rfc2119" title="SHOULD">SHOULD</em> support any status code defined in [[RFC2616]].</p>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Message</th>
	  </tr>
	  <tr>
	    <td>304 (Not Modified)</td>
        <td>not_modified</td>
	    <td>No changes have been made by the server.</td>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>bad_request	</td>
	    <td>The server is unable to fulfil the client request because the request is malformed.</td>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>filter_invalid</td>
	    <td>Filter requested on non-primitive type.</td>
	  </tr>
    <tr>
	    <td>400 (Bad Request)</td>
	    <td>invalid_duration</td>
	    <td>Time duration is invalid.</td>
	  </tr>
    <tr>
	    <td>400 (Bad Request)</td>
	    <td>invalid_value</td>
	    <td>The requested set value is invalid.</td>
	  </tr>    
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>token_expired</td>
	    <td>Access token has expired.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>token_invalid</td>
	    <td>Access token is invalid.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>token_missing</td>
	    <td>Access token is missing.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>too_many_attempts</td>
	    <td>The client has failed to authenticate too many times.</td>
	  </tr>	  
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>read_only</td>
	    <td>The desired signal cannot be set since it is a read only signal.</td>
	  </tr>	
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>user_forbidden</td>
	    <td>The user is not permitted to access the requested resource. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>user_unknown</td>
	    <td>The user is unknown. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>device_forbidden</td>
	    <td>The device is not permitted to access the requested resource. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>device_unknown</td>
	    <td>The device is unknown. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>invalid_path</td>
	    <td>The specified data path does not exist.</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>private_path</td>
	    <td>The specified data path is private and the request is not authorized to access signals on this path.</td>
	  </tr>
    <tr>
	    <td>404 (Not Found)</td>
	    <td>unavailable_data</td>
	    <td>The requested data was not found.</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>invalid_subscriptionId</td>
	    <td>The specified subscription was not found.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>insufficient_priviledges</td>
	    <td>The priviledges represented by the access token are not sufficient.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>not_acceptable</td>
	    <td>The server is unable to generate content that is acceptable to the client</td>
	  </tr>
	  <tr>
	    <td>429 (Too Many Requests)</td>
	    <td>too_many_requests</td>
	    <td>The client has sent the server too many requests in a given amount of time.</td>
	  </tr>
	  <tr>
	    <td>502 (Bad Gateway)</td>
	    <td>bad_gateway</td>
	    <td>The server was acting as a gateway or proxy and received an invalid response from an upstream server.</td>
	  </tr>
	  <tr>
	    <td>503 (Service Unavailable)</td>
	    <td>service_unavailable</td>
	    <td>The server is currently unable to handle the request due to a temporary overload or scheduled maintenance (which may be alleviated after some delay).</td>
	  </tr>
	  <tr>
	    <td>504 (Gateway Timeout)</td>
	    <td>gateway_timeout</td>
	    <td>The server did not receive a timely response from an upstream server it needed to access in order to complete the request.</td>
	  </tr>
	</tbody></table>
      </section>

      <section id="transport-payload">
        <h2>Transport Payload</h2>
        <p>The payload SHALL have JSON format. 
        See <a href='#json-def'></a> for the payload format of the messages for the different transport protocols.
        </p>
      </section>

      <section id="authorization">
        <h2>Authorization</h2>
          <p>Clients must provide a token to the server in order to verify that it is correctly authorized for the service it requests 
          (see CORE document).Tokens are integrated in HTTP requests in the <code>Authorization</code> header. 
          For WebSocket requests an optional <code>authorization</code> property in the payload can be used.
          </p>
      </section>
    </section>

    <section id="transport-protocols">
      <h2>Transport Protocols</h2>
      <p>The transport protocols supported are the secure versions of HTTP, WebSocket, and MQTT, 
      the latter on which a thin application layer protocol is applied.<br>
      The server MUST support the HTTP and WebSocket protocols, other protocols are optional. <br>
      Further transport protocols may be supported in future versions of this specification. 
      </p>

      <section id="https">
        <h2>HTTPS</h2>
        <p>The message data components described in the CORE document are in the first hand mapped to required HTTP parameters, 
        and only when there is no appropriate mapping it is mapped to the payload. 
        The subscribe/unsubscribe messages are not supported by this transport protocol.
        </p>

        <section id="https-life-time-mngmnt">
          <h2>Session Life Time Management</h2>

          <section id="https-initialisation">
            <h2>Initialization</h2>
            <p>N/A?</p>
          </section>

          <section id="https-closure">
            <h2>Closure</h2>
            <p>N/A?</p>
          </section>
        </section>

        <section id="https-transport-messages">
          <h2>Transport Messages</h2>

          <section id="https-read">
            <h2>Read</h2>
            <p>
            The client MAY send a HTTPS GET request message to the server to get one or more value(s) of one or more vehicle signal(s). 
            If the server is able to satisfy the request it SHALL return a response containing the requested value(s). 
            If the server is unable to fulfil the request, e.g. because the client is not authorized to retrieve one or more of the signals, 
            then the server response SHALL have the status code set to indicate error.
            </p>
            <p>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Cabin/SeatPosCount   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Successful response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                “data”:{“path”:”Vehicle.Cabin.SeatPosCount”, 
                        “dp”:{“value”:[”2”, "3", "2"], “ts”:”2020-04-15T13:37:00Z”}
                       }
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "error": {"number": 404, "reason": "invalid_path", "message": "The specified data path does not exist."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="https-authorized-read">
            <h2>Authorized Read</h2>
            <p>
            JWT tokens will be sent in the <code>Authorization</code> header, following with term <code>Bearer</code> and a space character.
            </p>
            <p>
            The following example assumes 
            <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds</code> 
            is the actual token. A token header can be combined with all types of read requests. 
            <br>
            <b>Example:</b>
            Request:		    
            <pre><code>
            GET /Vehicle/Drivetrain/InternalCombustionEngine/RPM   HTTP/1.1
            Host:127.0.0.1:1337
            Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds
            </code></pre>
            Successful response:
            <pre><code>
            HTTP/1.1 200 OK
            Content-Type: application/json; charset=utf-8
	    ...
            {
              “data”:{“path”:”Vehicle/Drivetrain/InternalCombustionEngine/RPM”, 
                      “dp”:{“value”:”2372”, “ts”:”2020-04-15T13:37:00Z”}
                     }
            }
            </code></pre>
            Error response:
            <pre><code>
            HTTP/1.1 401 Unauthorized
            WWW-Authenticate: Bearer realm="127.0.0.1:1337",
                                     error="invalid_token",
                                     error_description="The access token is invalid or expired"	    
            Content-Type: application/json; charset=utf-8
	    ...
            {
              "error": {"number": 401, "reason": "token_invalid", "message": "Access token is invalid."},
              "ts": "2020-04-15T13:37:00Z"
            }
            </code></pre>
	    </p>
          </section>

          <section id="https-search-read">
            <h2>Search Read</h2>
            <p>
              The search read request uses the query pattern described in the CORE document to provide one or more path expressions, 
              relative to the path in the GET URL.<br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Cabin/Door?filter={"type":"paths", "value":"*/*/IsOpen"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                “data”:[{“path”:”Vehicle/Cabin/Door/Row1/Left/IsOpen”, “dp”:{“value”:”false”, “ts”:”2020-04-15T13:37:00Z”}}, 
                        {...},… 
                        {“path”:”Vehicle/Cabin/Door/Row4/Right/IsOpen”, “dp”:{“value”:”true”, “ts”:”2020-04-15T13:37:00Z”}}
                       ]
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "error": {"number": 404, "reason": "invalid_path", "message": "The specified data path does not exist."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>		  
            </p>
          </section>

          <section id="https-history-read">
            <h2>History Read</h2>
            <p>
              The history read request uses the query pattern described in the CORE document to read recorded values 
              for a given period backwards in time.<br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle.Acceleration.Longitudinal?filter={"type":"history", "value":"P2DT12H"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                “data”:{“path”:”Vehicle.Acceleration.Longitudinal”, “dp”:[{“value”:”0.123”, “ts”:”2020-04-15T13:00:00Z”}, ..., {“value”:”0.125”, “ts”:”2020-04-15T13:37:00Z”}]}
              }
              </code></pre>
            </p>
          </section>

          <section id="https-service-discovery-read">
            <h2>Signal Discovery Read</h2>
            <p>
              The signal discovery request uses the URL fragment pattern as described in the CORE document to retrieve the static metadata, 
              i. e. the metadata defined in the VSS tree.
              If the value is set to an empty string, then all metadata in the addressed VSS nodes is returned. 
              If only specific metadata is desired, the value can be set to this, e. g. "value":["type", "datatype"]. 
              The values must be the names as defined in the VSS specification.<br>
              <br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle/Drivetrain/FuelSystem?filter={"type":"static-metadata", "value":""}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "metadata": {"FuelSystem":{"type":"branch","description":"Fuel system data.","children":{"HybridType, ... }}},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>

          <section id="https-dynamic-metadata-read">
            <h2>Dynamic Metadata Read</h2>
            <p>
              The dynamic metadata, i. e. any other metadata kept by the vehicle system, 
              is retrieved by the setting the "type" to  "dynamic-metadata".
              The value MUST be set to one of the domain names as specified in the CORE: Dynamic Metadata Filter Operation chapter.
              <br>
              <b>Example:</b>
              Request:
              <pre><code>
              GET /Vehicle?filter={"type":"dynamic-metadata", "value":"server_capabilities"}   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              </code></pre>
              Response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "metadata": {"filter":["timebased", "change", "paths", "curvelog", "dynamic-metadata"], "access_ctrl": ["short_term", "signalset_claim"], "transport_protocol": "https", "wss"},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>
        </section>

          <section id="https-update">
            <h2>Update</h2>
            <p>
            The client may request that the server sets the value of one or more signals e.g. to lock one or more doors or 
            open a window by sending an HTTPS POST request to the server. 
            In the case of several signals being set, they MUST all be of the same data type, and be set to the same value. 
            If the server is able to satisfy the request its response SHALL have a 200 OK status code set. 
            If an error occurs e.g. because the client is not authorized to set the requested value, or the value is read-only, 
            the server response SHALL have the status code set to indicate error.
            </p>
            <p>
              <b>Example:</b>
              <pre><code>
              POST /Vehicle/Drivetrain/Transmission/PerformanceMode   HTTP/1.1
              Host: 127.0.0.1:1337
              Accept: application/json
	      ...
              {
                "value": "sport"
              }
              </code></pre>
              Successful response:
              <pre><code>
              HTTP/1.1 200 OK
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
              Error response:
              <pre><code>
              HTTP/1.1 404 Not Found
              Content-Type: application/json; charset=utf-8
	      ...
              {
                "error": {"number": 404, "reason": "invalid_path", "message": "The specified data path does not exist."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="https-authorized-update">
            <h2>Authorized Update</h2>
            <p>
            JWT tokens will be sent in the <code>Authorization</code> header, following with term <code>Bearer</code> and a space character.
            </p>
            <p>
            The following example assumes 
            <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds</code> 
            is the actual token. A token header can be combined with all types of update requests.
            </p>
            <pre><code>
            POST /Vehicle/Drivetrain/Transmission/PerformanceMode   HTTP/1.1
            Host:127.0.0.1:1337
            Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UifQ.xuEv8qrfXu424LZk8bVgr9MQJUIrp1rHcPyZw_KSsds
            {
              "value": "sport"
            }
            </code></pre>
          </section>
          </section>
        </section>
      </section>

      <section id="secure-websocket">
        <h2>Secure WebSocket</h2>
        <p>
        As the WebSocket protocol does not implicitly provide a logical association between the request and response messages 
        described here a key-value pair with the keyname "requestId" is added to the data components described in the CORE document. 
        As the WebSocket protocol neither specifies a set of explicit methods, 
        another key-value pair with the keyname "action" is also added. See <a href='#action-def'></a> for the declaration of these new key-value pairs. 
        All data components are mapped to the payload.
        </p>

        <section id="wss-lifetime-mngmnt">
          <h2>Session Life Time Management</h2>

          <section id="wss-initialisation">
            <!--OddPage--><h2>Initialization</h2>

	<p>If the client application is an HTML Application running in a web
	runtime or is a web page running in a browser, the WebSocket
	instance may either be instantiated natively or be created using a
	'standards compliant' WebSocket JavaScript library.</p>
	<p>A WebSocket can also be initiated from a native (e.g. C++) Application
	or from an Application written using a 'Managed Runtime' language like
	Java or C#. It is assumed that native and managed clients use a
	suitable standards compliant WebSocket library to request that a
	WebSocket connection is opened on the server.</p>

	<p>Implementations that support additional devices or multiple VISSv2 services
        should provide discovery. Alternatively, the location of a particular VISSv2
        Server instance on the local vehicle network may be handled by
        configuration, either as part of a package manifest or by consulting a
        registry on application install. The 'wwwVISSv2' hostname in this
        specification is used an example.
	</p>
	      
	<p>A client running on the vehicle is able to connect to the
	VISSv2 Server instance using the hostname e.g. 'wwwVISSv2' and uses the
	default port 443. The hostname 'wwwVISSv2' may locally be mapped to the localhost
	IP address 127.0.0.1 e.g. by adding an entry to the /etc/hosts file.</p>

	<p>The sub-protocol name <em class="rfc2119" title="SHALL">SHALL</em> be 'VISSv2' with the digit 2 being the version number. 
	The sub-protocol version will
	be associated with exactly one VISS Server Specification version so that the client and server can 
	correctly validate and parse request and response message packets.</p>
        <pre><code>
	var vehicle  = new WebSocket("wss://wwwVISSv2:443", "VISSv2");
        </code></pre>
	<p>The client <em class="rfc2119" title="SHALL">SHALL</em> connect to the server over HTTPS and request that
	the server opens a WebSocket. All WebSocket communications between
	the client and server <em class="rfc2119" title="MUST">MUST</em> be over ‘wss’. Non encrypted communication
	is not supported, hence the server <em class="rfc2119" title="MUST">MUST</em> refuse ‘ws’ connection requests.</p>
	      
        <p>This specification assumes that a single WebSocket is used to enable communication between a client application
        and the server. The client MAY open more than one websocket.
        However, the server <em class="rfc2119" title="MAY">MAY</em> refuse to open a subsequent WebSocket connection and 
        the client is responsible for handling this gracefully.
        </p>

        <p>If more than one WebSocket connection is established between a client application and the server then each connection
        <em class="rfc2119" title="MUST">MUST</em> be managed independently. For example, subscriptions created using a particular 
        WebSocket connection shall only trigger notifications via that connection and the client 
        <em class="rfc2119" title="MUST">MUST</em> use that WebSocket connection to unsubscribe. 
        </p>

        <p>If more than one WebSocket connection has been established
        between one or more clients and a particular server instance, there
        is a risk that race conditions and concurrency issues could occur.
        An example of this would be where two or more WebSocket connections
        are used to update a particular setting at the same time.
        </p>

        <p>Unless explicitly stated otherwise, the client <em class="rfc2119" title="MAY">MAY</em> only assume
        that the server implements a simple concurrency model where lost
        updates and dirty reads could potentially occur if the server has
        more than one WebSocket connection open.
        </p>	 
          </section>

          <section id="wss-closure">
            <!--OddPage--><h2>Closure</h2>
	<p>The WebSocket may be closed by either the client or the
	server by invoking the ‘close()’ method on the WebSocket
	instance.</p>

	<p>The following example shows the lifetime of a WebSocket on
	the client:</p>
        <pre><code>
	// Open the WebSocket</span>
	var vehicle  = new WebSocket("wss://wwwVISSv2:443", "VISSv2");
	…
	// Close the WebSocket
	vehicle.close();
        </code></pre>
	<p>The VISSv2 Server may terminate the WebSocket connection if it has not received a request for a period determined by
	the server. It is the client’s responsibility to handle this gracefully and to recover and request new subscriptions, where required.
	</p>
        </section>
      </section>

      <section id="wss-transport-messages">
          <h2>Transport Messages</h2>

          <section id="wss-read-message">
            <h2>Read</h2>
            <p>The client <em class="rfc2119" title="MAY">MAY</em> send a <a href="#dfn-getrequest" class="internalDFN" data-link-type="dfn">getRequest</a> 
            message to the server to get the value of one or more vehicle signals. 
            If the server is able to satisfy the request it <em class="rfc2119" title="SHALL">SHALL</em> return a 
            <a href="#dfn-getsuccessresponse" class="internalDFN" data-link-type="dfn">getSuccessResponse</a> message. 
            If the server is unable to fulfil the request, e.g. because the client is not authorized to retrieve one or more of the signals, 
            then the server <em class="rfc2119" title="SHALL">SHALL</em> return a 
            <a href="#dfn-geterrorresponse" class="internalDFN" data-link-type="dfn">getErrorResponse</a> message. 
            The structure of these message objects is defined below.
            </p><br>
            <table class="simple">
            <thead>
              <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
            </thead>
            <tbody>
                <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-getrequest">getRequest</dfn></th></tr>
                <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
                <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
	        <tr><td><a href="#dfn-filter">filter</a></td><td>string</td><td>Optional</td></tr>		    
                <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
                <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
            </tbody>
            </table>
            <br>
            <table class="simple">
            <thead>
              <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
            </thead>
            <tbody>
             <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-getsuccessresponse">getSuccessResponse</dfn></th></tr>
             <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
             <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
             <tr><td><a href="#dfn-value">data</a></td><td>object/array</td><td>Yes</td></tr>
           </tbody>
           </table>
           <p>
           In the table above the "data" attribute is either an object containing "value" and "ts" name/value pairs, or an array of such objects. 
           </p>
           <table class="simple">
           <thead>
             <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
           </thead>
           <tbody>
           <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-geterrorresponse">getErrorResponse</dfn></th></tr>
           <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
           <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
           <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
           <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
           </tbody>
           </table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle/Drivetrain/InternalCombustionEngine/RPM",
                "requestId": "8756"
              }
              </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8756",
                “data”:{“path”:”Vehicle/Drivetrain/InternalCombustionEngine/RPM”, 
                        “dp”:{“value”:”2372”, “ts”:”2020-04-15T13:37:00Z”}
                       }
              }
              </code></pre>
              Error response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8756",
                "error": {"number": 404, "reason": "invalid_path", "message": "The specified data path does not exist."},
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>

          <section id="wss-authorized-read">
            <h2>Authorized Read</h2>
            <p> If the operation on the VSS node that is addressed requires authorization, 
               then the request must contain the field "authorization" with its value being a JWT token.
               The token validation must be successful for a 
               <a href="#dfn-getsuccessresponse" class="internalDFN" data-link-type="dfn">getSuccessResponse</a>
	       to be returned, else a <a href="#dfn-geterrorresponse" class="internalDFN" data-link-type="dfn">getErrorResponse</a> is returned. 
	       A token can be combined with all types of read requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle/Drivetrain/InternalCombustionEngine/RPM",
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds"
                "requestId": "8657"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "requestId": "8657",
                “data”:{“path”:”Vehicle/Drivetrain/InternalCombustionEngine/RPM”, 
                        “dp”:{“value”:”2372”, “ts”:”2020-04-15T13:37:00Z”}
                       }
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-search-read">
            <h2>Search Read</h2>
            <p>A client may issue a search read request to access multiple values in one request message. 
               This is realized by adding a "filter" object following the pattern described in the CORE spec, "Filtering" chapter.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle/Cabin",
                "filter": {"type":"paths", "value":["Door/*/*/IsOpen", "DriverPosition"]}
                "requestId": "5688"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                “data”:[{“path”:”Vehicle/Cabin/Door/Row1/Left/IsOpen”, “dp”:{“value”:”false”, “ts”:”2020-04-15T13:37:00Z”}}, 
                        {...},… 
                        {“path”:”Vehicle/Cabin/Door/Row4/Right/IsOpen”, “dp”:{“value”:”true”, “ts”:”2020-04-15T13:37:00Z”}},
                        {“path”:”Vehicle/Cabin/DriverPosition”, “dp”:{“value”:”1”, “ts”:”2020-04-15T07:00:00Z”}}
                       ]
                "requestId": "5688",
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-history-read">
            <h2>History Read</h2>
            <p>A client may issue a history read request to access recorded data points. 
               This is realized by adding a "filter" object following the pattern described in the CORE spec, "Filtering" chapter.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle.Acceleration.Longitudinal",
                "filter": {"type":"history", "value":"P2DT12H"},
                "requestId": "5688"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                “data”: {“path”: ”Vehicle.Acceleration.Longitudinal”, “dp”: [{“value”: ”0.123”, “ts”: ”2020-04-15T13:00:00Z”}, {“value”: ”0.125”, “ts”: ”2020-04-15T13:37:00Z”}]},
                "requestId": "5688"
              }
              </code></pre>
            </p>
          </section>

          <section id="wss-service-discovery-read">
            <h2>Signal Discovery Read</h2>
            <p>A client may issue a signal discovery read request to access dynamic metadata. 
               A successful response will contain the requested metadata from all nodes of the subtree defined by 
               the subtree root node that is addressed by the path.
              The static metadata, i. e. the metadata in the VSS tree, is retrieved by the setting the "type" to  "static-metadata", 
              and the "value" to relevant static metadata.<br>
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "get",
                "path": "Vehicle/Drivetrain/FuelSystem",
                "filter":{"type":"dynamic-metadata", "value":["availability", "validate"]}
                "requestId": "5687"
              }
              </code></pre>
              Response:
              <pre><code>
              {
                "action": "get",
                "requestId": "5687",
                "metadata": {"FuelSystem":{"availability":"available","validate":"read-write","children":{"HybridType", ... }}}
                "ts": "2020-04-15T13:37:00Z"
              }
              </code></pre>
            </p>
          </section>
          </section>

          <section id="wss-update">
            <h2>Update</h2>
            <p>
            The client may request that the server sets the value of one or more signals e.g. to lock one or more doors or open a window by sending a 
            <a href="#dfn-setrequest" class="internalDFN" data-link-type="dfn">setRequest</a> message to the server. 
            In the case of several signals being set, they MUST all be of the same data type, and be set to the same value. 
            If the server is able to satisfy the request it <em class="rfc2119" title="SHALL">SHALL</em> return a 
            <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a> message. 
            If an error occurs e.g. because the client is not authorized to set the requested value, or the value is read-only, 
            the server <em class="rfc2119" title="SHALL">SHALL</em> return a 
            <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> message.
            </p>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-setrequest">setRequest</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
          <tr><td><a href="#dfn-value">value</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>  
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-setsuccessresponse">setSuccessResponse</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr> 
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-seterrorresponse">setErrorResponse</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "set",
                "path": "Vehicle/Drivetrain/Transmission/PerformanceMode",
                "value": "sport",
                "requestId": "5687"
              }
               </code></pre>
             Successful response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
             Error response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "error": {"number": 404, "reason": "invalid_path", "message": "The specified data path does not exist."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>

         <section id="wss-authorized-update">
            <h2>Authorized Update</h2>
            <p>If the operation on the VSS node that is addressed requires authorization, 
               then the request must contain the field "authorization" with its value being a JWT token.
               The token validation must be successful for a 
               <a href="#dfn-setsuccessresponse" class="internalDFN" data-link-type="dfn">setSuccessResponse</a> 
	       to be returned, else a <a href="#dfn-seterrorresponse" class="internalDFN" data-link-type="dfn">setErrorResponse</a> is returned. 
	       A token can be combined with all types of update requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "set",
                "path": "Vehicle/Drivetrain/Transmission/PerformanceMode",
                "value": "sport",
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds"
                "requestId": "5687"
              }
               </code></pre>
              Response:
              <pre><code>
              {
                "action": "set",
                "requestId": "5687",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>
          </section>

          <section id="subscribe">
            <h2>Subscribe</h2>
            <p>
            The client may send a <a href="#dfn-subscriberequest" class="internalDFN" data-link-type="dfn">subscribeRequest</a> message 
            to request a subscription to one or more signals, 
            thereby requesting the server to repeatedly return subscription notification messages, as specified by the "filter" query 
            (see CORE, "Filtering" chapter). 
            The server <em class="rfc2119" title="MAY">MAY</em> reduce the number of 
            <a href="#dfn-subscriptionnotification" class="internalDFN" data-link-type="dfn">subcriptionNotification</a> 
            messages sent to the client in order to reduce processing demands.<br>
            If the server is able to satisfy the request it SHALL return a 
            <a href="#dfn-subscribesuccessresponse" class="internalDFN" data-link-type="dfn">subscribeSuccessResponse</a> message. 
            If an error occurs e.g. because the client is not authorized to set the requested value, the server SHALL return a 
            <a href="#dfn-subscribeerrorresponse" class="internalDFN" data-link-type="dfn">subscribeErrorResponse</a> message.<br>
            The subscription variants are, as described in the CORE document:
	  <ul>
	  <li>timebased: notifications are issued at a regular time interval,</li>
	  <li>change: notifications are issued when the value has changed as specified,</li>
	  <li>range: notifications are issued when the value is in the specified range,</li>
	  <li>curvelog: notifications are issued when the buffer is full, and then processed according to the curve logging algorithm.</li>
	  </ul>
            </p>
	<table class="simple">
 	<thead>
	   <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	 </thead>
	 <tbody>
	   <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-subscriberequest">subscribeRequest</dfn></th></tr>
	   <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
	   <tr><td><a href="#dfn-filter">filter</a></td><td>string</td><td>Optional</td></tr>
	   <tr><td><a href="#dfn-authorization">authorization</a></td><td>string</td><td>Optional</td></tr>
	   <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr> 
	 </tbody>
	 </table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-subscribesuccessresponse">subscribeSuccessResponse</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr> 
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-subscribeerrorresponse">subscribeErrorResponse</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-subscriptionnotification">subscriptionNotification</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-value">data</a></td><td>object/array</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-subscriptionerrornotification">subscriptionErrorNotification</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle/Drivetrain/FuelSystem/Level",
                "filter": {"type":"timebased", "value":{"period":"500"}}
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error response:
              <pre><code>
              {
                "action": "subscribe",
                "requestId": "6578",
                "error": {"number": 404, "reason": "invalid_path", "message": "The specified data path does not exist."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Notification:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                “data”: {“path”: ”Vehicle/Drivetrain/FuelSystem/Level”, 
                        “dp”: {“value”: ”50”, “ts”: ”2020-04-15T13:37:00Z”}
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error notification:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                "error": {"number": 401, "reason": "token_expired", "message": "Access token has expired."},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>

          <section id="authorized-subscribe">
            <h2>Authorized Subscribe</h2>
            <p>
            If the operation on the VSS node that is addressed requires authorization, 
            then the request must contain the field "authorization" with its value being a JWT token.
            The token validation must be successful for a 
            <a href="#dfn-subscribesuccessresponse" class="internalDFN" data-link-type="dfn">subscribeSuccessResponse</a>
            to be returned, else a 
            <a href="#dfn-subscribeerrorresponse" class="internalDFN" data-link-type="dfn">subscribeErrorResponse</a> is returned. 
            An "authorization" key-value pair can be combined with all types of subscription requests.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle/Drivetrain/FuelSystem/Level",
                "filter": {"type":"range", "value":[{"logic-op":"gt", "boundary":"49"}, {"logic-op":"lt", "boundary":"51"}]},
                "authorization": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1...Zw_KSsds",
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Notification:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                “data”: {“path”: ”Vehicle/Drivetrain/FuelSystem/Level”, 
                        “dp”: {“value”: ”50”, “ts”: ”2020-04-15T13:37:00Z”}
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="curve-logging-subscribe">
            <h2>Curve Logging Subscribe</h2>
            <p>
            Curve logging data compression by eliminating data points that are within a set error margin is activated via a subscription request. 
            Notifications will be issued when the buffer becomes full, after insignificant data points have been eliminated.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle/Drivetrain/FuelSystem/Level",
                "filter": {"type":"curvelog", "value":{"maxerr":"0.5", "bufsize":"100"}},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Notification:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                “data”:{“path”: ”Vehicle/Drivetrain/FuelSystem/Level”, 
                        “dp”:[{“value”: ”50”, “ts”: ”2020-04-15T13:38:00Z”}, ..., {“value”: ”25”, “ts”: ”2020-04-15T13:39:30Z”}]
                },
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>

          <section id="range-subscribe">
            <h2>Range Subscribe</h2>
            <p>
            Subscription to a range of values, that can be either unbounded, or bounded as in the example below.
            </p>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "subscribe",
                "path": "Vehicle/Drivetrain/FuelSystem/Level",
                "filter": "filter":{"type":"range","value":[{"logic-op":"gt","boundary":"50"},{"logic-op":"lt","boundary":"55"}]},
                "requestId": "6578"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "subscribe",
                "subscriptionId": "12345",
                "requestId": "6578",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Notification:
              <pre><code>
              {
                "action": "subscription",
                "subscriptionId": "12345",
                “data”:{“path”: ”Vehicle/Drivetrain/FuelSystem/Level”, 
                        “dp”:{“value”: ”51”, “ts”: ”2020-04-15T14:00:00Z”},
                "ts": "2020-04-15T14:00:00Z"
              }
               </code></pre>
            </p>
          </section>
          </section>

          <section id="unsubscribe">
            <h2>Unsubscribe</h2>
            <p>
            To unsubscribe from a subscription, the client <em class="rfc2119" title="SHALL">SHALL</em> send an 
            <a href="#dfn-unsubscriberequest" class="internalDFN" data-link-type="dfn">unsubscribeRequest</a> message to the server. 
            If the server is able to satisfy the request it returns an 
            <a href="#dfn-unsubscribesuccessresponse" class="internalDFN" data-link-type="dfn">unsubscribeSuccessResponse</a> message. 
            If an error occurs, for example because an invalid subscriptionId is passed to the server, an 
            <a href="#dfn-unsubscribeerrorresponse" class="internalDFN" data-link-type="dfn">unsubscribeErrorResponse</a> message is returned.
            <br>
            If the client has created more than one WebSocket instance, it <em class="rfc2119" title="MUST">MUST</em> always unsubscribe 
            using the same WebSocket instance that was originally used to create the subscription.
            </p>
	<table class="simple">
	  <thead>
	    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	  </thead>
	  <tbody>
	    <tr><th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-unsubscriberequest">unsubscribeRequest</dfn></th></tr>
	    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  </tbody>
	  </table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="5"><dfn data-dfn-type="dfn" id="dfn-unsubscribesuccessresponse">unsubscribeSuccessResponse</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
	<br>
	<table class="simple">
	<thead>
	  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
	</thead>
	<tbody>
	  <tr><th rowspan="6"><dfn data-dfn-type="dfn" id="dfn-unsubscribeerrorresponse">unsubscribeErrorResponse</dfn></th></tr>
	  <tr><td><a href="#dfn-action">action</a></td><td><a href="#action-def">Action</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-error">error</a></td><td><a href="#error-def">Error</a></td><td>Yes</td></tr>
	  <tr><td><a href="#dfn-ts">ts</a></td><td>string</td><td>Yes</td></tr>
	</tbody>
	</table>
            <p>
              <b>Example:</b><br>
              Request:
              <pre><code>
              {
                "action": "unsubscribe",
                "subscriptionId": "12345",
                "requestId": "5786"
              }
               </code></pre>
              Successful response:
              <pre><code>
              {
                "action": "unsubscribe",
                "subscriptionId": "12345",
                "requestId": "5786",
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
              Error response:
              <pre><code>
              {
                "action": "unsubscribe",
                "requestId": "6578",
                "error": {"number": 404, "reason": "invalid_subscriptionId", "message": "The specified subscription was not found"},
                "ts": "2020-04-15T13:37:00Z"
              }
               </code></pre>
            </p>
          </section>
        </section>
      </section>

      <section id="Defs">
        <h2>MQTT</h2>

        <section id="term-def">
          <h2>Application Level Protocol</h2>
          <p>
            For MQTT to support the complete VISSv2 interface, as decribed in the "Interface" chapter of the CORE specification, 
            an application level protocol that runs on top of MQTT is added. 
            It is described in the following, please also see the sequence diagram below. 
            To emulate the client-server pattern that is described in the CORE specification, the vehicle server, via its vehicle client, 
            issues a subscribe request to the broker on a topic named VID/Vehicle, 
            where VID is an identity that uniquely links to the vehicle in the access control ecosystem. 
            This vehicle identity is not necessarily the manufacturer's Vehicle Identification Number (VIN).<br>
            The client on the "cloud side" of the broker is expected to have access to this vehicle identity. 
            How it obtains it is out of scope for this specification. 
            When the cloud client wants to issue a request to the vehicle server it first generates a unique topic name, 
            which it subscribes to at the broker. It then generates a JSON formatted payload with the general structure<br>
            {"topic":"aUniqueTopic", "request":"VISSv2Request"}<br>
            where "aUniqueTopic" is the uniques topic name it just subscribed to, and "VISSv2Request" is the request for the vehicle server. 
            This request MUST follow the payload format that is specified in the Websocket chapter of this specification.
            This JSON message is then issued to the broker, associated to the topic VID/Vehicle. 
            This message will then be forwarded by the broker to the vehicle client, which forwards the string being the value of the 
            "request" key in the message to the vehicle server. When the vehicle client receives the response to this request, 
            it publishes it to the broker associated with the topic name that was the string value of the "topic" key name in the 
            message it previously received from the broker.<br>
            The broker will then forward this message to the cloud side client that earlier subscribed to this topic name, 
            which concludes the client-server based request-response as described in the CORE specification.<br>
            In the case of subscription requests the vehicle client needs to save the subscriptionId found in the subscribe response, 
            together with the topic name associated to the subscribe request. When the vehicle server later issues notifications, 
            the vehicle client must parse the subscriptionId from it, and retrieve the topic name associated to it. 
            The vehicle client shall delete the saved topic name and subscriptionId when it receives 
            an unsubscribe request in a message from the broker.<br>
            In following requests from the cloud side client, the unique topic name may be reused from the previous request-response cycle, 
            or a new unique topic name may be generated. If a new topic name is generated, an unsubscribe should be issued on the old topic name. 
            The vehicle client can continue to use the topic name it subscribes to.<br>
            The payload format of the responses/notifications SHALL follow the payload format that is specified 
            in the Websocket chapter of this specification. 
            The access control model is applicable also over this transport alternative. 
            The Access Token server should then implement its own version of the application level protocol described here, 
            using the topic name "VID/ATS". The Access Grant Token server may also do the same, with the topic name "VID/AGTS", 
            or if it is deployed in the cloud it may expose the HTTP interface that is defined in this specification.
          <img src="images/mqtt_vissv2_protocol.jpg" alt="VISSv2 over MQTT.">
          </p>
        </section>

        <section id="term-def">
          <h2>Security Aspects</h2>
          <p>
            The MQTT architecture mandates a "broker" that acts as a middleman in between the client and server endpoints 
            (the subscriber and the publisher in MQTT terminology). 
            This broker has full access to the plaintext communication between the two endpoints as each of the endpoint's 
            TLS channel terminates at the broker. This aspect should be considered when selecting to use the MQTT protocol.
          </p>
        </section>

        <section id="term-def">
          <h2>Transport Messages</h2>
          <p>
            As mentioned in the "Application Level Protocol" chapter, the "request" messages issued to the broker contains two 
            JSON formatted key-value pairs, where the value of the "request" key is a string that contains the request the vehicle server 
            will receive. The format of this request MUST follow the payload format that is specified in the Websocket chapter of this specification.
          </p>
        </section>
      </section>
      </section>

      <section id="Defs">
        <h2>Definitions</h2>

        <section id="term-def">
          <h2>Term Definitions</h2>
	<table class="parameters">
	  <tbody><tr>
	    <th>Attribute</th>
	    <th>Type</th>
	    <th>Description</th>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-action">action</dfn></td>
	    <td> <a href="#action-def">Action</a></td>
	    <td>The type of action requested by the client or delivered by the server.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-path">path</dfn></td>
	    <td>String</td>
	    <td>The path to a node in the VSS tree, as defined by the
	    <a href="https://github.com/GENIVI/vehicle_signal_specification">Vehicle Signal Specification (VSS)</a>.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-requestid">requestId</dfn></td>
            <td>String</td>
	    <td> Unique id value specified by the client. Returned by the server in
	    the response and used by the client to link the request and response
	    messages. The value <em class="rfc2119" title="MAY">MAY</em> be an integer or a Universally Unique Identifier (UUID).</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-subscriptionid">subscriptionId</dfn> </td>
            <td>String</td>
	    <td>Value returned by the server to uniquely identify each subscription.
	    The value <em class="rfc2119" title="MAY">MAY</em> be an integer or a Universally Unique Identifier (UUID).</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn> </td>
	    <td>string</td>
	    <td>A JWT formatted security token.</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-data">data</dfn> </td>
	    <td>object/array</td>
	    <td>Contains a path and one or more data points.</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-dp">dp</dfn> </td>
	    <td>object/array</td>
	    <td>The data point contains a value and a timestamp.</td>
	  </tr>
	  <tr>
	    <td><dfn data-dfn-type="dfn" id="dfn-ts">ts</dfn> </td>
	    <td>string</td>
	    <td>The Coordinated Universal Time (UTC) time stamp that represents the capture of the value.</td>
	  </tr>
	  <tr>
	    <td> <dfn data-dfn-type="dfn" id="dfn-value">value</dfn> </td>
	    <td>string</td>
	    <td> The data value associated with the path.</td>
	  </tr>
    <tr>
      <td> <dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn> </td>
      <td> string </td>
      <td>Provides a filtering mechanism to reduce the demands of a subscription on the server. Query format, see CORE:Filter Request.</td>
    </tr>
    <tr>
      <td> <dfn data-dfn-type="dfn" id="dfn-metadata">metadata</dfn> </td>
      <td> object </td>
      <td>Metadata describing the potentially available signal (sub)tree.</td>
    </tr>
	  <tr>
		  <td id="dfn-error"><strong>error</strong></td>
	    <td> <a href="#error-def">Error</a> </td>
	    <td> Returns an error code, reason and message.</td>
	  </tr>
	</tbody></table>
        </section>

        <section id="json-def">
          <h2>JSON Schema Definitions</h2>
          <p>
          The payload that is sent over the supported transport protocols SHALL use the JSON definitions in this appendix, 
          unless otherwise specified in the VISSv2 TRANSPORT specification.<br>
          The definitions within this section describe the datatypes referenced within the JSON Schema for the VISSv2 WebSocket interfaces, 
          and for the VISSv2 HTTP payloads.
          </p>
              <pre><code>
{
    "definitions": {
        "action": {
            "enum": [ "get", "set", "subscribe", "subscription", "unsubscribe"],
            "description": "The type of action requested by the client and/or delivered by the server",
        },
        "path": {
            "description": "The path to the desired vehicle signal(s). It may require synthesis with additional path data, see CORE:Paths Filter Operation",
            "type": "string"
        },
        "ts": {
            "description": "The time of the issuance of the message. For its format, see CORE: Timestamps.",
            "type": "string"
        },
        "filter": {
            "description": "May be specified in order to throttle the demands of subscriptions on the server. See CORE:Filter Request",
            "type": "object/array",
            "properties": {
                "type": {
                    "description": "The different filter types.",
                    "type": "string"
                },
                "value": {
                    "description": "Parameter(s) for the different filter types",
                    "type": "object/array",
                }
            }
        },
        "data": {
            "description": "Data including path(s) and one or more data point(s).",
            "type": "object/array",
            "properties": {
                "path": {
                    "description": "The path to the vehicle signal.",
                    "type": "string"
                },
                "dp": {
                    "description": "Data point including one or more value and time samp",
                    "type": "object/array",
                    "properties": {
                        "value": {
                            "description": "The value related to the associated path.",
                            "type": "string"                    
                        },
                        "ts": {
                            "description": "Time of the value capture. For its format, see CORE: Timestamps.",
                            "type": "string"                    
                        }
                    }
                }
            }   
        },
        "subscriptionId":{
            "description": "Integer handle value which is used to uniquely identify a subscription session.",
            "type": "string"
        },
        "metadata":{
            "description": "Static or dynamic metadata.",
            "type": "object"
        },
        "requestId": {
            "description": "Returned by the server in the response and used by the client to link the request and response messages.",
            "type": "string"
        },
        "error": {
            "description": "Server response for error cases",
            "type": "object",
            "properties": {
                "number": {
                    "description": "HTTP Status Code Number",
                    "type": "integer"                   
                },
                "reason": {
                    "description": "Pre-defined string value that can be used to distinguish between errors that have the same code",
                    "type": "string"                    
                },
                "message": {
                    "description": "Message text describing the cause in more detail",
                    "type": "string"                    
                }
            }   
        }
    }
}
               </code></pre>
        </section>

        <section id="action-def">
          <h2>Action Definitions</h2>
	<p>The Action enumeration is used to define the type of action requested by the client.
	All client messages <em class="rfc2119" title="MUST">MUST</em> contain a JSON structure that has an 
	<a href="#dfn-action" class="internalDFN" data-link-type="dfn">action</a> name/value pair and the
	value of the <a href="#dfn-action" class="internalDFN" data-link-type="dfn">action</a> property 
	<em class="rfc2119" title="MUST">MUST</em> be one of the values specified in the enumeration:</p>

	<dl title="enum Action" class="idl">
	  <dt><dfn data-dfn-type="dfn" id="dfn-get">get</dfn></dt>
	  <dd>Enables the client to read one or more values.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-set">set</dfn></dt>
	  <dd>Enables the client to update one value.</dd>
    <dt><dfn data-dfn-type="dfn" id="dfn-subscribe">subscribe</dfn></dt>
    <dd>Enables the client to request notifications containing a JSON data structure with values for one or more
      vehicle signal.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-unsubscribe">unsubscribe</dfn></dt>
	  <dd>Enables the client to request that it should no longer receive notifications based on that subscription.</dd>
    <dt><dfn data-dfn-type="dfn" id="dfn-subscription">subscription</dfn></dt>
    <dd>Enables the server to send notifications to the client containing a JSON data structure with values for one or more
      vehicle signals.</dd>
	  </dl>
        </section>

        <section id="error-def">
          <h2>Error Definitions</h2>
          <p>The error number SHOULD be a status code defined in [[RFC2616]], c. f. chapter "Status codes". 
          The error reason SHOULD be the corresponding reason-phrase from [[RFC2616]]. 
          The error message is meant to give a more precise description of the error.
          </p>
<table class="simple">
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-error-0">Error</dfn></th>
      </tr><tr><td><a href="#status-codes">number</a></td><td>integer</td><td>Yes</td></tr>
      <tr><td><a href="#status-codes">reason</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#status-codes">message</a></td><td>string</td><td>Yes</td></tr>
    
  </tbody>
  </table>
        </section>

    <div id="tof" class="appendix"></div>
  </body>
</html>
