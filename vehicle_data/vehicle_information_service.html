<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Vehicle Information Service Specification</title> 
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
    <script class="remove">
      var respecConfig = {
          specStatus:           "ED",
          shortName:            "vehicle-information-service",
          editors:  [{
            name: "Kevin Gavigan", company: "Jaguar Land Rover",
            url: "mailto:kgavigan@jaguarlandrover.com",
	    companyURL: "http://www.jaguarlandrover.com/",
	    w3cid: 71411
          }, {
            name: "Adam Crofts", company: "Jaguar Land Rover",
            url: "mailto:acrofts1@jaguarlandrover.com",
	    companyURL: "http://www.jaguarlandrover.com/",
	    w3cid: 74857
          }, {
            name: "이원석(Wonsuk Lee)", company: "한국전자통신연구원(ETRI)",
            url: "mailto:wonsuk.lee@etri.re.kr",
	    companyURL: "https://www.etri.re.kr/",
	    w3cid: 34457
          }, {
            name: "Powell Kinney", company: "Vinli",
            url: "mailto:powell@vin.li",
	    companyURL: "https://www.vin.li/",
	    w3cid: 83094
          }],
          edDraftURI:           "https://w3c.github.io/automotive/vehicle_data/vehicle_information_service.html",
          wg:           "Automotive Working Group",

          otherLinks: [{
            key: 'Repository and Participation',
            data: [
                {
                    value: 'We are on github.',
                    href: 'https://github.com/w3c/automotive/'
                }, {
                    value: 'File a bug/issue.',
                    href: 'https://github.com/w3c/automotive/issues'
                }, {
                    value: 'Commit history.',
                    href: 'https://github.com/w3c/automotive/commits'
                }, {
                    value: 'Mailing list archive.',
                    href: 'https://lists.w3.org/Archives/Public/public-automotive/'
                }
             ]
          }],

          wgURI:        "https://www.w3.org/auto/wg/",
          wgPublicList: "public-automotive",
          wgPatentURI: "https://www.w3.org/2004/01/pp-impl/76043/status",
	  
          localBiblio: {
            "VSS": {
              title: "Vehicle Signal Specification",
              href: "https://github.com/GENIVI/vehicle_signal_specification",
              status: "1.0",
              "date": "March 2017",
              publisher: "GENIVI Alliance",
            }
          },	      
      };
    </script>
    <style>
        table.parameters, table.exceptions {
            border-spacing: 0;
            border-collapse:    collapse;
            margin: 0.5em 0;
            width:  100%;
        }
        table.parameters { border-bottom:  1px solid #90b8de; }
        table.exceptions { border-bottom:  1px solid #deb890; }

        .parameters th, .exceptions th {
            color:  inherit;
            padding:    3px 5px;
            text-align: left;
            font-weight:    normal;
        }
        .parameters th { color: #fff; background: #005a9c; }
        .exceptions th { background: #deb890; }

        .parameters td, .exceptions td {
            padding:    3px 10px;
            border-top: 1px solid #ddd;
            vertical-align: top;
        }

        .parameters tr:first-child td, .exceptions tr:first-child td {
            border-top: none;
        }

        .parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
            width:  100px;
        }

        .parameters td.prmType {
            width:  120px;
        }

        table.exceptions table {
            border-spacing: 0;
            border-collapse:    collapse;
            width:  100%;
        }

        .simple {
          width:100%;
        }

        thead th{
          border-bottom: 1px solid black;
        }

        .simple tbody th{
          width:33%;
          background: white;
          color: black;        
        }
        pre { white-space: pre-wrap;}
    </style>
  </head>

  <body>
    <!-- Abstract -->
    <section id="abstract">
	<p>This specification defines a WebSocket based API for a Vehicle Information Service (VIS) to enable client applications to get, set, subscribe and unsubscribe to vehicle signals and data attributes.</p>
	<p>The purpose of the specification is to promote a Server API that enables application development in a consistent manner across participating automotive manufacturers.</p>
	  </section>

    <!-- Status of this document -->
    <section id="sotd">
    </section>

    <!-- Introduction -->
    <section id="introduction" class="informative">
      <h2>Introduction</h2>

      <p>This specification describes how a vehicle can expose vehicle signals and static data via a WebSocket. This
      enables a client to GET or SET vehicle signals and data; to SUBSCRIBE to receive
      notifications and to UNSUBSCRIBE from receiving notifications.</p>

      <p>The API that is used to manage access to vehicle signals and static data is defined in this Vehicle Information Service 
	 Specification (VISS). The VISS also describes a discovery mechanism that defines the set of signals and data that a client can access at a 
         particular point in time.</p>
	    
      <p>The term 'signal' is used here to represent an item of	data that can vary over time, for example vehicle speed,
	 whilst the expression 'static data' is used to denote a temporally invariant property like vehicle width.</p>

      <p>A vehicle-based software module may implement the interface and behaviours defined in this specification by creating a 
      WebSocket server instance that listens for an inbound connection request from a client in order to enable secure access to vehicle signals. 
      In this specification this module is referred to as the <dfn>VIS Server</dfn> or just 'the server'.</p>

      <p>The Vehicle Information Service Specification (VISS) defines a number of methods for accessing vehicle data which are strictly agnostic to the data model. Any data model where data and signals can be specified using a string could potentially be supported. However this version of the specification specifies that the data model is the GENIVI Vehicle Signal Specification [[!VSS]]. The VSS supports both extensibility and the ability to define private branches and will be used for each of the examples within this specification.</p>

      <p>In addition, the 'tree' of signals that is accessible at any point in time may also vary depending on standard access control principles.
         That is, it can vary based on the identity of the user (person or organisation) requesting the data and/or the application or 
	 device (e.g. vehicle) where the request originates.</p>

      <p>To support this, the Service Specification describes an extensible token based security mechanism that can optionally be used 
	 to pass tokens to the VIS Server,
        for example to represent the user of an application and/or the device that the client application is running on.</p>

      <p>A future revision of this specification may consider additionally exposing vehicle signals
      via a RESTful web service but this is out of scope for this version of the specification.</p>

      <p>It is recommended that this Vehicle Information Service Specification (VISS) is read in conjunction with the W3C Vehicle 
      Information API Specification (VIAS). The VIAS defines a client API that wraps the data access 
      and security primitives defined in this Service Specification. It has been defined to support the development of  
      'standards-compliant' JavaScript libraries that can be used by web based clients.</p> 
     <p>Use of the VIAS is optional as any client that can instantiate a WebSocket may connect to the VIS Server directly. The following example is for illustrative purposes only, it does not show error handling and is not intended to be commercial code.</p>

 <pre class="example highlight">
// Open the WebSocket
var vehicle  = new WebSocket("wss://wwwivi", "wvss1.0");

// Establish authorization
vehicle.onopen = function () {
  vehicle.send('{"action": "authorize", "tokens": {"authorization": "user_token_value"}, "requestId": "103"}');
};

// Message response handler for all possible actions
vehicle.onmessage = function(event){
  var msg = JSON.parse(event.data);
  switch(msg.action){
    case "authorize":
      authHandler(msg);
      break;
    case "getMetadata":
      getMetadataHandler(msg);
      break;
    case "get":
      getReqHandler(msg);
      break;
    case "set":
      setReqHandler(msg);
      break;
    case "subscribe":
      subscriptionSetupHandler(msg);
      break;
    case "subscription":
      subscriptionHandler(msg);
      break;
    case "unsubscribe":
      unsubscribeHandler(msg, false);
      break;
    case "unsubscribeAll":
      unsubscribeHandler(msg, true);
      break;
  }
};

// Auth request handler
function authHandler(msg) {
  if(msg.hasOwnProperty("TTL")){
    console.log("authorization successful");
    requestMetadata();
  } else {
    console.log("authorization unsuccessful");
  }
}

// Close the WebSocket to end the WebSocket session
function closeSocket(){
  vehicle.close();
}
  </pre>
  <p>Once the WebSocket connection has been established, the client is able to retrieve the metadata from the server and request signals for the client's current level of authentication.</p>
  <pre class="example highlight">
// Request the entire data model, in this example the data model is defined using GENIVI's VSS
function requestMetadata(){
  vehicle.send('{"action": "getMetadata", "requestId": "103"}');
}

// Request the entire data model and if successful, request a signal
function getMetadataHandler(msg){
  if(msg.hasOwnProperty('metadata')){
    console.log("Metadata Received");
    console.log("Metadata: " + JSON.stringify(msg.metadata));
    getSignal(msg.metadata, "Signal.Drivetrain.Transmission.Speed");
  } else {
    console.log("getMetadata Error");
  }
}

// Request a signal
function getSignal(metadata, path){
  // A check could be made here to ensure the signal is available within the metadata
  vehicle.send('{"action": "get", "path": ' + path + ', "requestId": "105"}');
}
  </pre>

  <p>The client is also able to subscribe to signals if the client's authentication permits access.</p>

  <pre class="example highlight">
// Set a subscription, assuming the same authorization and set up from Example 1
var rpmSubscriptionId, rpmRequestId = "106";

// Set up the subscription
function subscribeToRPMNotifications(){
  vehicle.send('{"action": "subscribe", "path": "Signal.Drivetrain.InternalCombustionEngine.RPM",  "requestId": ' + rpmRequestId + '}');
}

// Handle the subscription response
function subscriptionSetupHandler(msg){
    if(msg.hasOwnProperty("requestId") && msg.requestId == rpmRequestId){
      console.log("Subscription set with a subscription ID of " + msg.subscriptionId);
      rpmSubscriptionId = msg.subscriptionId;
    }
}

// Handle the subscription notification
function subscriptionHandler(msg){
    if(msg.hasOwnProperty("subscriptionId") && msg.subscriptionId == rpmSubscriptionId){
      console.log("The current engine rpm is " + msg.value);
    }
}

  </pre>
        <p>The target platform supported by the specification is exclusively passenger vehicles. Use of this
	specification for non-passenger applications (for example heavy machinery, marine and airline infotainment) is
	not prohibited, but is not covered in the design or content of the API.</p>

	<p>An example use case could be the implementation of a 'Home Mechanic' application that provides warnings if any
	the following need attention: tire pressure, engine oil level, washer fluid level and battery charge level.</p>

	<p>Exposing vehicle signals in a standardized manner facilitates the integration of vehicles within the Web of Things (WoT)
	and supports future use case innovations in a variety of fields including transportation, safety, navigation, energy management,
	smart transportation and consumer infotainment.</p>
	    
	<p>The data format used for client/server communication within this specification is JSON encoded strings, however other data formats may be supported in future versions of the specification.</p>
      </section>

      <!-- Conformance -->
      <section id="conformance">
	<p>This specification defines conformance criteria that apply to a single product: specifically the 'in-vehicle'
	WebSocket <dfn>Vehicle Information Service</dfn> that implements the interfaces, semantics and behaviour
		defined in this document.</p>
      </section>

      <!-- Terminology -->
      <section id="terminology">
	<h2>Terminology</h2>
  <p> The acronym 'VISS' is used to refer to this document, the 'Vehicle Information Service Specification'.</p>
  <p> The acronym 'VIAS' is used to refer to the 'Vehicle Information API Specification' (see <a href="https://w3c.github.io/automotive/vehicle_information_api/vehicle_information_api_specification.html">here</a>) which has been developed alongside the VISS to expose a client API which can implement the VISS.</p>
  <p> The acronym 'VSS' is used to refer to the 'Vehicle Signal Specification' (see <a href="https://github.com/GENIVI/vehicle_signal_specification/">here</a>) which is defined by the GENIVI Alliance.
  </p>

 	<p>The term 'WebSocket' when used in this document, is as defined in the W3C WebSocket API
 	(see <a href="https://www.w3.org/TR/2011/WD-websockets-20110929">here</a>) and the WebSocket Protocol
 	(see <a href="https://tools.ietf.org/html/rfc6455">RFC6455</a>).</p>
      </section>

      <!-- Table of Figures -->
      <section id="tof"></section>

      <!-- Architecture -->
      <section id="architecture" class="informative">
        <h2>Architecture</h2>
        <h3>Overview</h3>
      <p>In a typical vehicle design, signals and data are transmitted between Electronic Control Units (ECUs) connected
      via internal vehicle networks. These include Controller Area Networks (CAN), Media Oriented Systems Transport (MOST)
      and Local Interconnect Networks (LIN). ECUs on these networks broadcast messages on network buses, and other ECUs on the
      bus respond to the messages.</p>

      <p>In the component diagram included in Figure 2, the internal vehicle CAN, MOST and LIN networks and the ECUs that communicate
      via these networks are abstracted and for simplicity, represented by the <dfn>System</dfn> component.</p>

      <p>For safety, security and commercial reasons not all clients should be able to GET, SET or SUBSCRIBE to particular vehicle
      signals and data attributes. As a consequence, access-control must be managed so clients cannot simply connect directly to ECUs
      or to CAN, MOST or LIN network buses.</p>

      <p>In this specification, the term 'signal' refers to a value that can change over time, for example, vehicle speed,
      whilst 'static data' or simply 'data' is used for a value that does not change e.g. vehicle length.</p>

      <p>The vehicle signals and static data that are available within the vehicle System are exposed in a controlled
      manner to the VIS Server. The interface and communication mechanisms that are used between the vehicle System and
      the VIS Server are outside of the scope of this specification.</p>

      <h3>Vehicle Information Service (VIS) Server</h3>
      <p>As stated above, the <strong>VIS Server</strong> is the 'in-vehicle' system that is responsible for
	      exposing vehicle signals and data to on-board clients by implementing the interface and behaviours defined in this
	      <dfn>Vehicle Information Service Specification (VISS)</dfn>.</p>

      <p>The VIS Server exposes signals and data in a manner that is consistent with the accompanying data model. The data model is not mandated by this specification, however the recommended data model used within this specification is the <dfn>Vehicle Signal Specification (VSS)</dfn>.
      This defines a 'tree-like' logical taxonomy of the vehicle, (formally a Directed Acyclic Graph), where major vehicle structures
      (e.g. body, engine) are near the top of the tree and the logical assemblies and components that comprise them, are defined as
      their child nodes. Each of the child nodes in the tree is further decomposed into its logical constituents, and the process is
      repeated until <dfn>leaf nodes</dfn> are reached. A 'leaf node' is a node at the end of a branch that cannot be decomposed
      because it represents a single signal or data attribute value. An example VSS tree is shown below, its contents are illustrative:</p>
	      
      <figure>
        <img src="images/VSS_Tree_Simple_Example_v1.png" alt="Diagram showing an example Vehicle Signal tree">
        <figcaption>Diagram showing an example Vehicle Signal Tree</figcaption>
      </figure>
	      
      <p>Within GENIVI's VSS data model, signals are named according to their path using the dot notation e.g. engine.rpm. The methods defined within this document support any path notation which can be represented as a string.</p>

      <p>The client may invoke the VIS Server's <a>getMetadata</a> method to request that the server returns metadata that
      describes which signals and data attributes could potentially be accessed provided that the user and/or device is suitably
      authorized. This and other valid VIS Server actions are defined in more detail <a href="#action">here</a>.</p>

      <h3>In-Vehicle Clients</h3>
      <p>In-vehicle clients include both those clients that are running on an ECU in the vehicle itself,
      e.g. an ECU that implements an In-Vehicle Infotainment (IVI) system, but also includes clients running on a user's
      device, e.g. a laptop, phone or tablet, that is connected via the vehicle's WiFi client (if one exists).</p>

      <figure>
        <img src="images/W3C_Vehicle_API_Component_Diagram_v1_5.png" alt="Component diagram showing W3C Vehicle Information APIs">
        <figcaption>Diagram showing Components that implement the W3C Vehicle Information APIs and their clients</figcaption>
      </figure>

      <p>The methods defined on the VIS Server interface may be invoked by different types of on-board and off-board clients.
      On-board clients, running on the vehicle fall into one of two major categories:</p>

      <p><dfn>Applications</dfn> running in the vehicle that can access vehicle signals and data and have a User Interface that
      the driver or passengers in the vehicle can interact with.</p>

      <p><dfn>Agents</dfn> typically have no user interface. They can also invoke methods exposed on the VIS Server but their
      purpose is to connect to one or more off-board e.g. <dfn>Vehicle to Everything (V2X)</dfn> internet Servers in order to send
      data off-board.</p>

      <p>Both applications and agents can be subdivided into those that are web-based and which run in a 'Web Runtime' and are
      implemented using Web Standards like HTML, CSS and JavaScript; those that run in their own native process written using
      e.g. C, C++ or Objective-C; and those that run in a Managed Runtime process written using languages like C#
      or Java.</p>

      <p>Web applications and web agents may directly invoke the Vehicle Information Service interface exposed by the VIS Server,
      but it is expected that they typically access vehicle signals and data via a JavaScript Library that implements the
      W3C Vehicle Information API Specification (VIAS) (see <a href="https://w3c.github.io/automotive/vehicle_information_api/vehicle_information_api_specification.html">here</a>). The VIAS is a client API that defines a 
      standard approach to encapsulate or 'wrap' the API defined in this specification to make it easier for Web based clients to 
      access vehicle signals and data in a controlled way.</p>

      <h3>Sending Signals and Data off-board</h3>
      <p>In addition to local, in-vehicle applications and agents, a variety of internet-based clients and servers may be interested
      in accessing vehicle signals and data. However, when a vehicle is not being used, most electrical systems are shut down in
      order to maximize battery life. This may include the systems that enable Wireless or Mobile connectivity. When the vehicle
      is powered up, various systems start up, including potentially those that provide off-board connectivity and the vehicle typically
      connects either to a local WiFi network or to a Mobile Network Operator (MNO) and is dynamically assigned an IP address.</p>

      <p>At this point, internet based clients and servers do not know the dynamic IP address that was assigned to a specific vehicle.
      So normally, a vehicle has to connect to a well known endpoint, generally using a URL to connect to a V2X Server.
      The vehicle and the internet server typically mutually authenticate and the vehicle 'registers' with the V2X server over
      an encrypted channel passing it a unique identifier e.g. its Vehicle Identification Number (VIN). From that point on, the V2X server
      has the IP address that is currently assigned to a vehicle with a particular VIN, and can share this information with other
      internet based clients and servers, which are then able to send messages to the vehicle.</p>

      <p>However, if the vehicle loses connectivity and is dynamically assigned a new IP address, it needs to re-register its new
      IP address and the new address needs to be communicated to any interested parties. For simplicity, this is not shown in the
      component diagram, primarily because this connectivity only becomes possible after the vehicle has registered with at least one
      off-board server (which is shown) but also because these scenarios do not affect the interface and behaviours defined in this
      Vehicle Information Service Specification.</p>

      <p>The component diagram shows four different types of internet based clients. A user may use a <dfn>Web Page</dfn> or a <dfn>
      Web Application</dfn> running on a phone or tablet connected to the vehicle's ethernet network to request access to vehicle 
      signals on a particular vehicle. Alternatively these signals could be accessed using a <dfn>Native or Managed Runtime Application</dfn> or via another automated
      <dfn>Client System</dfn> or service e.g. the Traffic Management System in a 'Smart City'.</p>
           	      
      <h3>VIS Server State Diagram</h3>
      <p>The following diagram shows a number of possible states that the VIS Server could occupy:</p>
      <figure>
        <img src="images/VISS State Diagram v1_2.png" alt="State Diagram for VIS Server">
        <figcaption>State diagram for the VIS Server</figcaption>
      </figure>
      <p>The state diagram is for illustrative purposes only and does not assume that the VIS Server is either single or multi-threaded.
      The implementer of the VIS Server is free to determine it's internal design and implementation, however in normal operation, 
      it is assumed that the server will be able to accept multiple requests in quick succession and that the VIS Server 
      will attempt to process and respond to each request in accordance with the specified API.</p>
      </section>

      <!-- Security and privacy -->
      <section id="security">
        <h2>Security and Privacy Considerations</h2>
        <h3>Introduction</h3>
        <p>The VIS Server implementation MAY optionally restrict access to one or more vehicle signals so that they can only
	be accessed in response to a request from an authorized user and/or device. This could be for a variety of
	reasons, including safety, privacy or commercial considerations.</p>

	<p>Hence, a request to GET, SET, SUBSCRIBE or UNSUBSCRIBE to data may require the client to demonstrate
	to the server that the request is from one or more suitably authorized Security Principals.</p>

        <p>The different types of Security Principal, the approach taken to control access to signals and the importance of data privacy are described in the sections that follow.</p>

        <h3>Security Principals</h3>
	<p>The types of security principal include:</p>

        <table class="parameters">
	  <tr>
	    <th>Type</th>
	    <th>Description</th>
	  </tr>
	  <tr>
	    <td>User</td>
	    <td>A person, system or organisation responsible for making the request e.g. driver, Emergency Services,
	        Smart City Traffic Management System.</td>
	  </tr>
	  <tr>
	    <td>Device</td>
	    <td>Vehicle or device where the request originates. Could for example be a user's Consumer Electronics
		(CE) device connected to the vehicle's WiFi hotspot or another vehicle in a convoy;  an Electronic Control
		Unit (ECU) on the same vehicle or any internet connected system e.g. a Web of Things (WoT) device.</td>
	  </tr>
        </table>

	<h3>Access Control and Authorization</h3>
        <p>When a client makes a request to access signal data it is performing the request on behalf of one or more
        Security Principals, that is, for a particular user and/or vehicle/device.</p>

        <p>Access to signals is managed and controlled by the server. The server MAY elect not to enforce access
        controls on a particular signal or set of signals and to enforce different access controls on other signals.</p>

        <p>For each security principal that must be authorized by the server, the client SHALL obtain and pass a security token
        e.g. an OAuth 2.0 token (see <a href="https://tools.ietf.org/html/rfc6749">RFC6749</a>) to the server using a message
        containing an 'authorize' action as defined <a href="#authorize">here</a>.</p>

        <p>A server implementation MAY require that a request for a particular signal includes a security token for
        both the user (e.g. driver of the vehicle) and for the device (e.g. the vehicle) that is hosting the client.
        A request for a different set of vehicle signals MAY require that only the user is authorized or that only the device
        is authorized to access particular signals.</p>
	      
	<p>The client and the server are each individually responsible for implementing security best practice. This includes
	but is not limited to securely obtaining and verifying tokens (as applicable) and the prevention of replays or spoofing
	of tokens by malicious actors or agents.</p>

        <h3>WebSocket Channel Authorization</h3>
        <p>The client MAY send a message with an 'authorize' action to modify the access-control state of the WebSocket channel.
        The message structure is defined in detail <a href="#message-structure">here</a>.</p>

        <p>The following diagram illustrates a scenario where the client requests vehicle speed. In this example scenario, this
        signal is not under access control and so the server returns a message containing the requested data. The client then
        requests that the server sets the vehicle trunk status to open and the server demands that the client passes access-control
        credentials before satisfying the request. The sequence of steps is illustrated in the diagram below:</p>

        <figure>
          <img src="images/WebSocket_Security_Flow_1_900px.png" alt="WebSocket Security token flow">
          <figcaption>Diagram showing conceptual WebSocket Security Token flow (data structures are illustrative and logical content has been simplified)</figcaption>
        </figure>

        <p>After receiving a message with an 'authorize' action the server attempts to verify the tokens e.g. by checking
        with the issuing Security Authority. If all of the tokens that are passed to the server are valid, it returns
        a success response and all subsequent requests received by the WebSocket instance have elevated access control
        privileges. Specifically, each of the GET, SET, SUBSCRIBE and UNSUBSCRIBE actions have the access control rights
        that the server deems to be appropriate for the security principals represented by the token(s).</p>

        <p>If the client sends a subsequent 'authorize' message to the server with different token value(s). If one or more of these
        are invalid, then the server returns an error response and the WebSocket access control status remain unchanged.
        However, if the new token values are valid, then the server returns a success response and the access control
        privileges associated with the new token(s) only, applies for all requests from that point.</p>

        <p>If the client or the server close the WebSocket connection and a new WebSocket instance is opened, then it is
        opened without elevated access control privileges.

        <p>This service specification defines a standardized, token based approach for access control that includes specific error
        responses for common user and device access control scenarios. It is important however, that the security model is extensible.
        Hence, the server MAY implement any type of token that is  consistent with this standardized approach and MAY optionally
        define additional token(s) for other Security Principal type(s). If this is the case, it is expected that the precise type of security tokens that are supported by a particular server
        implementation, the format of those tokens and all additional error codes and reasons (e.g. to indicate that an
        additional token type has expired and needs to be renewed) is defined in the Server's documentation.</p>

        <h3>Use of Encryption</h3>
        <p>To support a layered security model and to help establish a 'defence in depth', all vehicle signal and data communications
        between the client and server MUST be strongly encrypted. This is to make it more difficult for an attacker to eavesdrop or
        tamper with the security tokens; the request data or the response payload.</p>

        <p>One way in which this may be implemented is for the client and the server to use a Public Key Infrastructure (PKI)
        approach, where the client verifies the server's identity by checking the server's X.509 certificate and the client and
        the server negotiate to establish a secure Transport Layer Security (TLS) 'tunnel'.</p>

        <p>The WebSocket protocol mandates that if a client requests that the server opens a WebSocket connection and the request
        is received over HTTPS, then the WebSocket is established over TLS, that is, a secure 'wss' connection is created.</p>

        <h3>Token Renewal</h3>
        <p>Each security token SHALL have a specified lifetime during which it is valid. If on receiving a request for signals that are
        subject to access-control, the server determines that the request is unauthorized because the token has expired, the server
        SHALL return an error response indicating the fact and the client SHALL request a new token from the Security Authority and
        repeat the request.</p>

        <p>If the server returns an error response indicating that the request is forbidden, renewing the security token does
        not make the request valid. In this case, the client should not repeat the request unless some other change has been made
        that may mean the request is now valid.</p>
      </section>


      <!-- Initialisation of the WebSocket -->
      <section>
	<h3>Initialisation of the WebSocket</h3>

	<p>If the client application is an HTML Application running in a web
	runtime or is a web page running in a browser, the WebSocket
	instance may either be instantiated natively or be created using a
	'standards compliant' WebSocket JavaScript library.</p>
	<p>A WebSocket can also be initiated from a native (e.g. C++) Application
	or from an Application written using a 'Managed Runtime' language like
	Java or C#. It is assumed that native and managed clients use a
	suitable standards compliant WebSocket library to request that a
	WebSocket connection is opened on the server.</p>

	<p>A client running on the vehicle is able to connect to the
	VIS Server instance using the hostname 'wwwivi' and uses the
	default port 443. The hostname 'wwwivi' may locally be mapped to the localhost
	IP address 127.0.0.1 e.g. by adding an entry to the /etc/hosts file.</p>

	<p>The sub-protocol name SHALL be 'wvss' with a version number suffix, e.g. wvss1.0. The sub-protocol version will
	be associated with exactly one Vehicle Server Specification (VSS) version so that the client and server can 
	correctly validate and parse request and response message packets.</p>
	<pre class="highlight hljs javascript">
	  <span class="hljs-keyword">var</span> vehicle  = new WebSocket("wss://wwwivi", "wvss1.0");
	</pre>
	
	<p class="note">Discuss merits of using 'wwwivi' as a standardized hostname. Do we want a more generic 
		hostname, not just for IVI but also encompassing WoT standards?</p>
	      
	<p>The client SHALL connect to the server over HTTPS and request that
	the server opens a WebSocket. All WebSocket communications between
	the client and server MUST be over ‘wss’. Non encrypted communication
	is not supported, hence the server MUST refuse ‘ws’ connection requests.</p>
	      
        <p>This specification assumes that a single WebSocket is used to enable communication between a client application
        and the server. It is not explicitly prohibited for the client to request that the server opens more than one WebSocket,
        however, the server MAY refuse to open a subsequent WebSocket connection and the client is responsible for handling this
        gracefully.</p>

        <p>If more than one WebSocket connection is established between a client application and the server then each connection
        MUST be managed independently. For example, subscriptions created using a particular WebSocket connection shall only trigger
        notifications via that connection and the client MUST use that WebSocket connection to unsubscribe. </p>

        <p>If more than one WebSocket connection has been established
        between one or more clients and a particular server instance, there
        is a risk that race conditions and concurrency issues could occur.
        An example of this would be where two or more WebSocket connections
        are used to update a particular setting at the same time.</p>

        <p>Unless explicitly stated otherwise, the client MAY only assume
        that the server implements a simple concurrency model where lost
        updates and dirty reads could potentially occur if the server has
        more than one WebSocket connection open.</p>	      
      </section>

      <!-- Message Structure -->
      <section>
      <h3>Message Structure</h3>

       <p>The client MUST use the WebSocket <dfn>send</dfn> method, defined
       <a href="https://www.w3.org/TR/2011/WD-websockets-20110929/#the-websocket-interface">here</a>,
        to pass request messages to the server. The message signature SHALL be:</p>

	<pre class="highlight hljs javascript">
		WebSocket.send(request)
	</pre>
	<p>The request message MUST be comprised of one the request objects defined in this section. The client SHALL
	receive responses from the server using the WebSocket <dfn>onmessage</dfn> method, as follows:</p>
	<pre class="highlight hljs javascript">
		WebSocket.onmessage = function(obj){
			// process data
		}
	</pre>
	<p>The message returned by the server MUST be one of the response objects defined in the table below.</p>

	<table class="parameters">
	  <tr>
	    <th>Request Objects</th>
	    <th>Response Objects</th>
	  </tr>
	  <tr>
	    <td><a>authorizeRequest</a></td>
	    <td>
	    	<a>authorizeSuccessResponse</a><br>
			<a>authorizeErrorResponse</a>
		</td>
	  </tr>
	  <tr>
	    <td><a>metadataRequest</a></td>
	    <td>
		<a>metadataSuccessResponse</a><br>
	        <a>metadataErrorResponse</a>
	    </td>
	  </tr>		
	  <tr>
	    <td><a>getRequest</a></td>
	    <td>
	    	<a>getSuccessResponse</a><br>
			<a>getErrorResponse</a>
		</td>
	  </tr>
	  <tr>
	    <td><a>setRequest</a></td>
	    <td>
	    	<a>setSuccessResponse</a><br>
			<a>setErrorResponse</a>
		</td>
	  </tr>
	  <tr>
	    <td><a>subscribeRequest</a></td>
	    <td>
	    	<a>subscribeSuccessResponse</a><br>
			<a>subscribeErrorResponse</a><br>
			<a>subscriptionNotification</a><br>
		    <a>subscriptionNotificationError</a>
		</td>
	  </tr>
	  <tr>
	    <td><a>unsubscribeRequest</a></td>
	    <td>
	    	<a>unsubscribeSuccessResponse</a><br>
			<a>unsubscribeErrorResponse</a>
		</td>
	  </tr>
    <tr>
      <td><a>unsubscribeAllRequest</a></td>
      <td>
        <a>unsubscribeAllSuccessResponse</a><br>
      <a>unsubscribeAllErrorResponse</a>
    </td>
    </tr>
	</table>

	<p>The request and response parameters contain a limited number of attributes, defined in the table below.</p>
  	<h4></h4><h4></h4>
  	<h4>Term Definitions</h4>
	<table class="parameters">
	  <tr>
	    <th>Attribute</th>
	    <th>Type</th>
	    <th>Description</th>
	  </tr>
	  <tr>
	    <td> <dfn>action</dfn></td>
	    <td> <a href="#action">Action</a></td>
	    <td>The type of action requested by the client or delivered by the server.</td>
	  </tr>
	  <tr>
	    <td> <dfn>path</dfn></td>
	    <td>String</td>
	    <td>The path to the desired vehicle signal(s), as defined by the
	    <a href="https://www.w3.org/auto/wg/wiki/Vehicle_Information_Service_Specification#Data_Model">
	    	Vehicle	Signal Specification (VSS)</a>.</td>
	  </tr>
	  <tr>
	    <td> <dfn>requestId</dfn></td>
      <td>String</td>
	    <td> Unique id value specified by the client. Returned by the server in
	    the response and used by client to link the request and response
	    messages. The value MAY be an integer or a Universally Unique Identifier (UUID).</td>
	  </tr>
	  <tr>
	    <td> <dfn>subscriptionId</dfn> </td>
      <td>String</td>
	    <td>Value returned by the server to uniquely identify each subscription.
	    The value MAY be an integer or a Universally Unique Identifier (UUID).</td>
	  </tr>
	  <tr>
	    <td><dfn>tokens</dfn> </td>
	    <td>object</td>
	    <td>Structure containing one or more security token (e.g OAuth2) name/value pairs.</td>
	  </tr>
	  <tr>
	    <td><dfn>timestamp</dfn> </td>
	    <td>integer</td>
	    <td>The Coordinated Universal Time (UTC) time that the server returned the response (expressed as number of milliseconds).</td>
	  </tr>
	  <tr>
	    <td> <dfn>value</dfn> </td>
	    <td> any </td>
	    <td> The data value returned by the server. This could either be a basic
	    type, or a complex type comprised of nested name/value pairs in JSON
	    format.</td>
	  </tr>
	  <tr>
	    <td> <dfn>TTL</dfn> </td>
	    <td> integer </td>
	    <td> Returns the time to live of the authorization token in seconds.</td>
	  </tr>
    <tr>
      <td> <dfn>filters</dfn> </td>
      <td> object </td>
      <td>Provides a filtering mechanism to reduce the demands of a subscription on the server.</td>
    </tr>
    <tr>
      <td> <dfn>metadata</dfn> </td>
      <td> object </td>
      <td>Metadata describing the potentially available signal tree.</td>
    </tr>
	  <tr>
		  <td id="dfn-error"><strong><italic>error</italic></strong></td>
	    <td> <a href="#errors">Error</a> </td>
	    <td> Returns an error code, reason and message.</td>
	  </tr>
	</table>
<h4>JSON Schema Definitions</h4>
<p>The definitions within this section describe the datatypes referenced within the JSON Schema VISS interfaces.</p>
<pre>
{
    "definitions": {
        "action": {
            "enum": [ "authorize", "getMetadata", "get", "set", "subscribe", "subscription", "unsubscribe", "unsubscribeAll"],
            "description": "The type of action requested by the client or delivered by the server",
        },
        "requestId": {
            "description": "Returned by the server in the response and used by the client to link the request and response messages.",
            "type": "string"
        },
        "path": {
            "description": "The path to the desired vehicle signal(s), as defined by the metadata schema.",
            "type": "string"
        },
        "value": {
            "description": "The data value returned by the server. This could either be a basic type, or a complex type comprised of nested name/value pairs in JSON format.",
            "type": "string"
        },
        "timestamp": {
            "description": "The Coordinated Universal Time (UTC) time that the server returned the response (expressed as number of milliseconds).",
            "type": "integer"
        },
        "filters": {
            "description": "May be specified in order to throttle the demands of subscriptions on the server.",
            "type": ["object", "null"],
            "properties": {
                "interval": {
                    "description": "The subscription will provide notifications with a period equal to this field's value.",
                    "type": "integer"                   
                },
                "range": {
                    "description": "The subscription will provide notifications only when within a given range.",
                    "type": "object",
                    "properties":{
                      "below": {
                        "description": "The subscription will provide notifications when the value is less or equal to this field's value.",
                        "type": "integer"  
                      },
                      "above": {
                        "description": "The subscription will provide notifications when the value is greater than or equal to this field's value.",
                        "type": "integer"  
                      }
                    }                   
                },
                "minChange": {
                    "description": "The subscription will provide notifications when a value has changed by the amount specified in this field.",
                    "type": "integer"                   
                }
            }
        },
        "subscriptionId":{
            "description": "Integer handle value which is used to uniquely identify the subscription.",
            "type": "string"
        },
        "metadata":{
            "description": "Metadata describing the potentially available signal tree.",
            "type": "object"
        },
        "error": {
            "description": "Server response for error cases",
            "type": "object",
            "properties": {
                "number": {
                    "description": "HTTP Status Code Number",
                    "type": "integer"                   
                },
                "reason": {
                    "description": "Pre-defined string value that can be used to distinguish between errors that have the same code",
                    "type": "string"                    
                },
                "message": {
                    "description": "Message text describing the cause in more detail",
                    "type": "string"                    
                }
            }   
        }
    }
}
</pre>

	<h4 id="action">Action</h4>

	<p>The Action enumeration is used to define the type of action requested by the client.
	All client messages MUST contain a JSON structure that has an 'action' name/value pair and the
	value of the 'action' property MUST be one of the values specified in the enumeration:</p>

	<dl title="enum Action" class="idl">
	  <dt><dfn>authorize</dfn></dt>
	  <dd>Enables client to pass security tokens for Security Principals to the server to support access-control.</dd>
	  <dt><dfn>getMetadata</dfn></dt>
	  <dd>Allows the client to request metadata describing signals and data attributes that are potentially accessible.</dd>
	  <dt><dfn>get</dfn></dt>
	  <dd>Enables the client to get one or more values once.</dd>
	  <dt><dfn>set</dfn></dt>
	  <dd>Enables the client to set one or more values once.</dd>
    <dt><dfn>subscribe</dfn></dt>
    <dd>Enables the client to request notifications containing a JSON data structure with values for one or more
      vehicle signals and/or data attributes. The client requests that it is notified when the signal changes on the server.</dd>
    <dt><dfn>subscription</dfn></dt>
    <dd>Enables the server to send notifications to the client containing a JSON data structure with values for one or more
      vehicle signals and/or data attributes.</dd>
	  <dt><dfn>unsubscribe</dfn></dt>
	  <dd>Allows the client to notify the server that it should no longer receive notifications based on that subscription.</dd>
	  <dt><dfn>unsubscribeAll</dfn></dt>
	  <dd>Allows the client to notify the server that it should no longer receive notifications for any active subscription.</dd>
	  </dl>

	<h2>Authorize</h2>
 	<p>To enable access to signals and data attributes that are under access control, the client MAY optionally pass a message
 	with an 'authorize' action to the server. The structure of the message and the associated success and error responses
         are defined below.</p>
<h4 data-idl id="idl-def-authorizerequest">Authorize Request Properties</h4>
<p>The properties and schema for an authorizeRequest is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='4'><dfn>authorizeRequest</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-tokens">tokens</a></td><td>object</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Authorize Request",
    "description": "Enables the user to set access controls for the vehicle signals",
    "type": "object",
    "required": ["action", "tokens", "requestId"],
    "properties": {
        "action": {
            "enum": [ "authorize" ],
            "description": "The identifier for the authorize request"
        },
        "tokens": {
            "description": "Extensible key-value pair token mechanism used for access control",
            "type": "object",
            "properties": {
                "authorization": {
                    "description": "The user token, for the user that the client is making requests on behalf of",
                    "type": "string"
                },
                "www-vehicle-device": {
                    "description": "The device token for the originating device that is making the request to the server",
                    "type": "string"
                }
            }
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for an authorizeSuccessResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='4'><dfn>authorizeSuccessResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-ttl">TTL</a></td><td>integer</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>    
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Authorize Success Response",
    "description": "The response sent from the server upon a successful authorization request",
    "type": "object",
    "required": ["action", "TTL", "requestId"],
    "properties": {
        "action": {
            "enum": [ "authorize" ],
            "description": "The identifier for the authorize request",
        },
        "TTL": {
            "description": "The time to live of the authorization token",
            "type": "integer"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for an authorizeErrorResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='4'><dfn>authorizeErrorResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>  
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Authorize Error Response",
    "description": "The response sent from the server upon an unsuccessful authorization request",
    "type": "object",
    "required": ["action", "error", "requestId"],
    "properties": {
        "action": {
            "enum": [ "authorize" ],
            "description": "The identifier for the authorize request",
        },
        "error": {
            "$ref": "#/definitions/error"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
    <p>The server SHALL provide support the following security token types and names:</p>

    <table class="parameters">
      <tr>
        <th>Security&nbsp;Principal</th>
        <th>Token Name</th>
        <th>Description</th>
      </tr>
      <tr>
        <td> <dfn>User</dfn></td>
        <td> <dfn>authorization</dfn></td>
        <td> The user that the client is making requests on behalf of. This MAY be a person e.g. driver or passenger, it MAY be
        an organisation e.g. Emergency Services or MAY be any other legal entity.</td>
      </tr>
      <tr>
        <td> <dfn>Device</dfn></td>
        <td> <dfn>www-vehicle-device</dfn></td>
        <td> The originating device that is making the request to the server. This MAY be an ECU in the vehicle that is hosting the
        VIS Server or MAY be a device that is connected to the vehicle via a WiFi hotspot or MAY be any other device.</td>
      </tr>
    </table>

    <p>The 'tokens' JSON fragment MAY contain an 'authorization' structure that contains just a single name/value pair, for example,
    to pass only the user token. Or it may contain only the 'www-vehicle-device' name/value pair to pass the just the vehicle token;
    alternatively it MAY include name/value pairs for both the 'authorization' and 'www-vehicle-device' tokens.
    These alternatives are illustrated in the following example:</p>

	<pre class="example highlight">
		if(userTokenOnly){
			// Pass user token only
			vehicle.send('{ "action": "authorize",
				"tokens": { "authorization": "&lt;user_token_value&gt;" },
				"requestId": "&lt;some_unique_value&gt;" }');

		} else if (deviceTokenOnly) {
			// Pass vehicle/device token only
			vehicle.send('{ "action": "authorize",
				"tokens": { "www-vehicle-device": "&lt;device_token_value&gt;" },
				"requestId": "&lt;some_unique_value&gt;" }');

		} else if (userAndDeviceToken) {
			// Pass tokens for user and device
			vehicle.send('{ "action": "authorize",
				"tokens": { "authorization": "&lt;user_token_value&gt;",
					"www-vehicle-device": "&lt;device_token_value&gt;" },
				"requestId": "&lt;some_unique_value&gt;" }');
		}
	</pre>

  <p>This specification purposely does not define the token structure and the methods to obtain token(s). Providers of the server implementation may select their own preferred token format and method for verifying the authenticity of token(s) passed to the server. The server may also treat tokens as opaque structures and pass them on to underlying software layers for evaluation.</p>

  <p>It is expected that client and server use the same token format. If a client presents a token using a 
	    format that is not understood by the server, the server rejects the token.</p>
	      
	<p>In order to make dictionary attacks more difficult, authentication will be denied after a number of failed authentication 
		requests. A 401 (Unauthorized) too_many_requests error will be sent by the server in response 
		to any subsequent authentication requests. The number of failed requests and the period 
		of time during which attempts will be denied is to be determined by the implementation.</p>    
	
	<h2>Metadata Request</h2>
	<p>The client MAY use the 'getMetadata' action to request metadata describing the potentially available signal schema, for example the VSS tree. It does
	this by sending a 'metadataRequest' message to the server. If the server is able to return the metadata, then this
	is returned using a 'metadataSuccessResponse' message. If an error occurs, the server returns a 'metadataErrorResponse'
	message to the client.</p>

	<p>The client is able to request metadata from any point in the signal tree, such that only the metadata for the signals
	within the given branch of the schema's hierachy is returned. For example, only metadata for the chassis branch of the VSS tree is returned
	when the chassis path is specified. If the path is not set, the response contains the metadata for the entire signal tree.</p>

        <p>If more than one 'getMetadata' call is made with the same 'metadataRequest' message content but at different times, the metadata
        in the 'metadataSuccessResponse' SHALL be the same provided the access-control state of the WebSocket channel has not changed.</p>

        <p>The Vehicle Signal Server (VSS) specification allows branches to be defined as either public or private. The VIS server will satisfy a request for metadata in a public branch regardless of the access control permissions associated with the client making the request. This means that a user could see that a particular signal in a public branch is available but they may not be currently authorised to Get, Set, or Subscribe to that signal. If a branch is defined to be 'private', only suitably authorised clients will be able to retrieve metadata for that branch. This is to enable vehicle manufacturers to 
        apply access controls to metadata for commercially sensitive signals and data.</p>

        <p>      
        If a signal is requested to which the client has no access then the server will reject the request as detailed by the Get, Set, and Subscribe sections of this specification. The server shall only return metadata for the branches and nodes which are classified as "Private" branch unless the client has appropriate access permissions. 



        Other data models may also operate similar mechanisms.</p>




      <h4 data-idl id="idl-def-metadataRequest">Metadata Request Properties</h4>
      <p>The properties and schema for a metadataRequest is:</p>
      <table class=simple>
      <thead>
        <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
      </thead>
      <tbody>
        <tr>
          <th rowspan='4'><dfn>metadataRequest</dfn></th>
          <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
          <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
          <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
        </tr>
      </tbody>
      </table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Metadata Request",
    "description": "Request metadata describing the potentially available signals",
    "type": "object",
    "required": ["action", "path", "requestId"],
    "properties": {
        "action": {
            "enum": [ "getMetadata" ],
            "description": "The identifier for the getMetadata request"
        },
        "path": {
            "$ref": "#/definitions/path"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for a metadataSuccessResponse is:</p>
    <table class=simple>
    <thead>
      <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
    </thead>
    <tbody>
      <tr>
        <th rowspan='5'><dfn>metadataSuccessResponse</dfn></th>
        <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
        <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
        <tr><td><a href="#dfn-metadata">metadata</a></td><td>object</td><td>Yes</td></tr>
        <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
      </tr>
    </tbody>
    </table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Metadata Success Response",
    "description": "The response sent from the server upon a successful getMetadata request",
    "type": "object",
    "required": ["action", "requestId", "metadata", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "getMetadata" ],
            "description": "The identifier for the getMetadata request"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "metadata": {
            "$ref": "#/definitions/metadata"
        },
	"timestamp": {
	    "$ref": "#/definitions/timestamp"
    	}
    }
}
</pre>
<p>The properties and schema for a metadataErrorResponse is:</p>
    <table class=simple>
    <thead>
      <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
    </thead>
    <tbody>
      <tr>
        <th rowspan='5'><dfn>metadataErrorResponse</dfn></th>
        <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
        <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
        <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
        <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
      </tr>
    </tbody>
    </table>
    <pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Metadata Error Response",
    "description": "The response sent from the server upon an unsuccessful getMetadata request",
    "type": "object",
    "required": ["action", "requestId", "error", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "getMetadata" ],
            "description": "The identifier for the getMetadata request"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "error": {
            "$ref": "#/definitions/error"
        },
	"timestamp": {
	    "$ref": "#/definitions/timestamp"
    	}
    }
}
</pre>
      <h4>Examples</h4>

    <p>The following data flow example shows a request for the signal structure within the Signal.Drivetrain.InternalCombustionEngine.RPM
	    branch containing the vehicle RPM signal, where the metadata is defined using a VSS tree. A leaf node has been chosen in this example for brevity, however entire VSS
	    branches and other schemas can also be requested using the getMetadata interface.</p>

    <pre class="highlight hljs javascript">
  client -> {
    "action": "getMetadata",
    "path": "Signal.Drivetrain.InternalCombustionEngine.RPM",
    "requestId": "3874"
  }
  receive <- {
    "action": "getMetadata",
    "requestId": "3874",
    "metadata": { "Signal": {
        "description": "All signals that can dynamically be updated by the vehicle",
        "type": "branch",
        "children": {
          "Drivetrain": {
            "description": "Drivetrain data for internal combustion engines, transmissions, electric motors, etc.",
            "type": "branch",
            "children": {
              "InternalCombustionEngine": {
                "description": "Engine-specific data, stopping at the bell housing.",
                "type": "branch",
                "children": {
                  "RPM": {
                    "description": "Engine speed measured as rotations per minute.",
                    "min": 0,
                    "max": 20000,
                    "type": "UInt16",
                    "id": 54,
                    "unit": "rpm"
                  }
                }
              }
            }
          }
        }
      }
    },
    "timestamp": 1496087968995
  }
  </pre>

  <p>The following data flow example shows a request for the VSS structure within the Attribute.Body branch of the VSS. The example assumes the VSS contains two leaf nodes within the Attribute.Body branch.</p>
    <pre class="highlight hljs javascript">
  client -> {
    "action": "getMetadata",
    "path": "Attribute.Body",
    "requestId": "3875"
  }
  receive <- {
    "action": "getMetadata",
    "requestId": "3875",
    "metadata": { "Attribute": {
        "description": "Attribute signals that do not change during the power cycle of a vehicle.",
        "type": "branch",
        "children": {
          "Body": {
            "description": "All body components",
            "type": "branch",
            "children": {
              "BodyType": {
                "description": "Body type code as defined by ISO 3779",
                "type": "string"
              },
              "RefuelPosition": {
                "description": "Location of the fuel cap or charge port",
                "type": "string",
                "enum": ["front_left", "front_right", "middle_left", "middle_right", "rear_left", "rear_right"]
              }
            }
          }
        }
      }
    },
    "timestamp": 1489985044000
  }
  </pre>


	<h2>Get</h2>
	<p>The client MAY send a 'getRequest' message to the server to get the value of one or more vehicle signals and data
	attributes. If the server is able to satisfy the request it SHALL return a 'getSuccessResponse' message. If the server
	is unable to fulfil the request, e.g. because the client is not authorized to retrieve one or more of the signals,
	then the server SHALL return a 'getErrorResponse'. The structure of these message objects is defined below:</p>

<h4 data-idl id="idl-def-getrequest">Get Request Properties</h4>
<p>The properties and schema for a getRequest is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='4'><dfn>getRequest</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Get Request",
    "description": "Get the value of one or more vehicle signals and data attributes",
    "type": "object",
    "required": ["action", "path", "requestId"],
    "properties": {
        "action": {
            "enum": [ "get" ],
            "description": "The identifier for the get request",
        },
        "path": {
            "$ref": "#/definitions/path"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for a getSuccessResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>getSuccessResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-value">value</a></td><td>object</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Get Success Response",
    "description": "The response sent from the server upon a successful get request",
    "type": "object",
    "required": ["action", "requestId", "value", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "get" ],
            "description": "The identifier for the get request",
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "value": {
            "$ref": "#/definitions/value"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<p>The properties and schema for a getErrorResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>getErrorResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Get Error Response",
    "description": "The response sent from the server upon an unsuccessful get request",
    "type": "object",
    "required": ["action", "requestId", "error", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "get" ],
            "description": "The identifier for the get request",
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "error": {
            "$ref": "#/definitions/error"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}

</pre>

      <h4>Examples</h4>
      <p>It is important to note that all examples involving paths are illustrative. Valid path values and the signals and data
      attributes that correspond to a particular path are defined in the Vehicle Signal Specification.</p>

      <p>The example below shows the JSON structure for a 'getRequest' message sent by the client to obtain the engine RPM value
      and a 'getSuccessResponse' returned by the server.</p>
	<pre class="highlight hljs javascript">
	client -> {
		"action": "get",
		"path": "Signal.Drivetrain.InternalCombustionEngine.RPM",
		"requestId": "8756"
	}

	receive <- {
		"action": "get",
		"requestId": "8756",
		"value": 2372,
		"timestamp": 1489985044000
	}
	</pre>

	<p>In the case where the server returns a value that is a <dfn>complex type</dfn>, i.e. a value that
	is not a single basic JavaScript type (e.g. String, Number, Boolean), the value SHALL be returned as
	a set of name/value pairs in a JSON object structure. The format MUST be as defined by the version of the Vehicle Signal 
	Specification that is associated with the WebSocket sub-protocol value specified when the WebSocket is created.<p>

	<p>The following shows an example of a 'getRequest' that results in the server returning a 'getSuccessResponse' with a value
	that is a complex type:</p>
	<pre class="highlight hljs javascript">
	client -> {
		"action": "get",
		"path": "Signal.Body.Trunk",
		"requestId": "9078"
	}

	receive <- {
		"action": "get",
		"requestId": "9078",
		"value": { "Signal.Body.Trunk.IsLocked": false,
			"Signal.Body.Trunk.IsOpen": true },
		"timestamp": 1489985044000
	}
	</pre>

	<p>One or more wildcards (denoted by asterisk '*') MAY be included at
	any level in the path to specify that all nodes at that level are to be included.</p>

	<p>In the example below, the path in the 'getRequest' includes a wildcard at the levels above
	the leaf (signal) node, in order to request just the 'IsLocked' state for all doors.</p>
	<pre class="highlight hljs javascript">
	client -> {
		"action": "get",
		"path": "Signal.Cabin.Door.*.IsLocked",
		"requestId": "4523"
	}

	receive <- {
		"action": "get",
		"requestId": "4523",
		"value": [ {"Signal.Cabin.Door.Row1.Right.IsLocked" : true },
		           {"Signal.Cabin.Door.Row1.Left.IsLocked" : true },
			       {"Signal.Cabin.Door.Row2.Right.IsLocked" : false },
			       {"Signal.Cabin.Door.Row2.Left.IsLocked" : true } ],
		"timestamp": 1489985044000
	}
	</pre>

	<p>In this example, a complex type with a nested array is returned in response to the Path: "Signal.Cabin.Door.*"
	which denotes: 'Return all signals and data attributes for all doors'. For simplicity, the example
	assumes that the VSS definition for each door only has two attributes 'IsLocked' and 'Window.Position'.</p>
	<pre class="highlight hljs javascript">
	client -> {
		"action": "get",
		"path": "Signal.Cabin.Door.*",
		"requestId": "6745"
	}

	receive <- {
		"action": "get",
		"requestId": "6745",
		"value": [ {"Signal.Cabin.Door.Row1.Right.IsLocked" : true, "Signal.Cabin.Door.Row1.Right.Window.Position": 50},
		           {"Signal.Cabin.Door.Row1.Left.IsLocked" : true, "Signal.Cabin.Door.Row1.Left.Window.Position": 23},
		           {"Signal.Cabin.Door.Row2.Right.IsLocked" : false, "Signal.Cabin.Door.Row2.Right.Window.Position": 100 },
		           {"Signal.Cabin.Door.Row2.Left.IsLocked": true, "Signal.Cabin.Door.Row2.Left.Window.Position": 0 } ],
		"timestamp": 1489985044000
	}
	</pre>
	<p>The following shows a request for non-existent data</p>
	<pre class="highlight hljs javascript">
	client -> {
		"action": "get",
		"path": "Body.Flux.Capacitor",
		"requestId": "1245"
	}

	receive <- {
		"action": "get",
		"requestId": "1245",
		"error": { "number":404,
			"reason": "invalid_path",
			"message": "The specified data path does not exist." },
		"timestamp": 1489985044000
	}
	</pre>
	<h2>Set</h2>

	<p>The client may request that the server sets the value of one or more signals e.g. to lock one or more doors or open a window by sending
	a 'setRequest' message to the server. If the server is able to satisfy the request it SHALL return a 'setSuccessResponse'
	message. If an error occurs e.g. because the client is not authorized to set the requested value, or the value is read-only,
	the server SHALL return a 'setErrorResponse' message.<p>
<p>The properties and schema for a setRequest is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>setRequest</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-value">value</a></td><td>any</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Set Request",
    "description": "Enables the client to set one or more values once.",
    "type": "object",
    "required": ["action", "path", "value", "requestId"],
    "properties": {
        "action": {
            "enum": [ "set" ],
            "description": "The identifier for the set request",
        },
        "path": {
            "$ref": "#/definitions/path"
        },
        "value": {
            "$ref": "#/definitions/value"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for a setSuccessResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='4'><dfn>setSuccessResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Set Success Response",
    "description": "The response sent from the server upon a successful set request",
    "type": "object",
    "required": ["action", "requestId", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "set" ],
            "description": "The identifier for the set request",
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<p>The properties and schema for a setErrorResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>setErrorResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Set Error Response",
    "description": "The response sent from the server upon an unsuccessful set request",
    "type": "object",
    "required": ["action", "requestId", "error", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "set" ],
            "description": "The identifier for the set request",
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "error": {
            "$ref": "#/definitions/error"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<h4>Examples</h4>
	<p>Successfully set a signal.</p>
	<pre class="highlight hljs javascript">
    client -> {
      "action": "set",
      "path": "Signal.Cabin.Door.*.IsLocked",
      "value": [ {"Row1.Right.IsLocked": true },
                 {"Row1.Left.IsLocked": true },
                 {"Row2.Right.IsLocked": true },
                 {"Row2.Left.IsLocked": true } ],
      "requestId": "5689"
    }

    receive <- {
        "action": "set",
        "requestId": "5689",
        "timestamp": 1489985044000
    }
	</pre>
	<p>Unsuccessful set. The value cannot be set.</p>
	<pre class="highlight hljs javascript">
    client -> {
        "action": "set",
        "path": "Signal.Drivetrain.InternalCombustionEngine.RPM",
        "value": 2000,
        "requestId": "8912"
    }

    receive <- {
        "action": "set",
        "requestId": "8912",
        "error": { "number": 401,
        "reason": "read_only",
        "message": "The desired signal cannot be set since it is a read only signal"},
        "timestamp": 1489985044000
    }
	</pre>
	<p>Unsuccessful set. The value does not exist in the specified path.</p>
	<pre class="highlight hljs javascript">
    client -> {
    "action": "set",
    "path": "Signal.Drivetrain.InternalCombustionEngine.RPM",
    "value": { "locked" : true }
    "requestId": "2311"
    }

    receive <- {
        "action": "set",
        "requestId": "2311",
        "error": { "number": 400,
        "reason": "bad_request" ,
        "message": "The server is unable to fulfil the client
                    request because the request is malformed."},
        "timestamp": 1489985044000
     }
	</pre>
	<h2>Subscribe</h2>
	<p>Vehicle data subscriptions provide data to the client whenever the signal changes on the server,
	unless otherwise specified using Server Side Filtering. The server MAY reduce the number of notifications
	sent to the client in order to reduce processing demands, particularly when the client has subscribed to
	continuously varying signals.</p>

	<p>When the client makes a request to the server to create a new
	subscription, a JSON data object is returned. This object contains
	the attributes that were passed to the server to make the
	subscription and a 'subscriptionId' integer handle value which is used to
	uniquely identify the subscription.</p>
      
 <h4 data-idl id="idl-def-subscriberequest">Subscribe Request Properties</h4>
 <p>The properties and schema for a subscribeRequest is:</p>
 <table class=simple>
 <thead>
   <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
 </thead>
 <tbody>
   <tr>
     <th rowspan='5'><dfn>subscribeRequest</dfn></th>
     <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
     <tr><td><a href="#dfn-path">path</a></td><td>string</td><td>Yes</td></tr>
     <tr><td><a href="#dfn-filters">filters</a></td><td>object</td><td>No</td></tr>
     <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
   </tr>
 </tbody>
 </table>
 
 <pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Subscribe Request",
    "description": "Allows the client to subscribe to time-varying signal notifications on the server.",
    "type": "object",
    "required": ["action", "path", "requestId"],
    "properties": {
        "action": {
            "enum": [ "subscribe" ],
            "description": "The identifier for the subscription request"
        },
        "path": {
            "$ref": "#/definitions/path"
        },
        "filters": {
            "$ref": "#/definitions/filters"
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for a subscribeSuccessResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>subscribeSuccessResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Subscribe Success Response",
    "description": "The response sent from the server upon a successful subscription request",
    "type": "object",
    "required": ["action", "requestId", "subscriptionId", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "subscribe" ],
            "description": "The identifier for the subscription request",
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "subscriptionId": {
            "$ref": "#/definitions/subscriptionId"
        },                
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<p>The properties and schema for a subscribeErrorResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>subscribeErrorResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Subscribe Error Response",
    "description": "The response sent from the server upon an unsuccessful subscribe request",
    "type": "object",
    "required": ["action", "requestId", "error", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "subscribe" ],
            "description": "The identifier for the subscription request",
        },
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "error": {
            "$ref": "#/definitions/error"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<p>The properties and schema for a subscriptionNotification is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>subscriptionNotification</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-value">value</a></td><td>any</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Subscription Notification",
    "description": "Notification sent from the server to provide the requested data to the client",
    "type": "object",
    "required": ["action", "subscriptionId", "value", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "subscription" ],
            "description": "The identifier for the subscription notification",
        },
        "subscriptionId": {
            "$ref": "#/definitions/subscriptionId"
        },
        "value": {
            "$ref": "#/definitions/value"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<p>The properties and schema for a subscriptionNotificationError is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>subscriptionNotificationError</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Subscription Notification Error",
    "description": "Error message sent by the server when there is an error with an existing subscription",
    "type": "object",
    "required": ["action", "subscriptionId", "error", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "subscription" ],
            "description": "The identifier for the subscription notification",
        },
        "subscriptionId": {
            "$ref": "#/definitions/subscriptionId"
        },
        "error": {
            "$ref": "#/definitions/error"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>


  <h4>Examples</h4>
  <p>For example when a client wishes to subscribe to receive "Signal.Drivetrain.Transmission.TripMeter" information from the server, 
  it can use the "subscribe" action with the target path property set as follows:</p>
	<pre class="highlight hljs javascript">
	client -> {
		"action": "subscribe",
		"path": "Signal.Drivetrain.Transmission.TripMeter",
		"requestId": "1004"
	}

	receive <- {
            "action": "subscribe",
            "requestId": "1004",
            "subscriptionId": "35472",
            "timestamp": 1489985044000
	}
  </pre>
  <p>This example is for illustrative purposes only, it MAY or MAY NOT be the case that the version of the Vehicle Server Specification
  implemented by the VIS Server includes the example path 'Signal.Drivetrain.Transmission.TripMeter'.</p>
  
  <p>If the "subscribe" request is successful the server will return a subscribeSuccessResponse as shown in the example above, 
  and the client will then start to  receive subscription notifications like the one illustrated in the following JSON structure:</p>

  <pre class="highlight hljs javascript">
      receive <- {
          "action": "subscription",
          "subscriptionId": "35472",
          "value": 36912,
          "timestamp": 1489985044000
      }
  </pre>

	</pre>
	<p>The 'subscriptionId' value is a unique value, created by the server and
	which may be used internally by the server to manage subscriptions
	on that WebSocket instance.</p>

	<p>The subscriptionId value may also be used by the client to
	unsubscribe from receiving future notifications, by passing the
	value to the server with the unsubscribe action.</p>

	<p>To differentiate subscription response from responses for ‘GET’
	requests, subscription responses shall additionally include the
	subscriptionId value that identifies the subscription that
	triggered that notification.</p>

	<p>The server ensures that a new unique subscriptionId value is
	returned for each successful subscription request on a particular
	WebSocket connection. However the server does not guarantee that
	subscription handle values are unique between different WebSocket
	instances.</p>

	<p>Once the subscription is successfully registered with the server,
	the client receives subscription notifications containing the requested
	data, at a rate defined either by the server or by the server side filter. If there is an
	error with an existing subscription a subscriptionNotificationError SHALL be sent to 
	the client. This allows the client to handle the error, for example by modifying the filter condition
	to reduce the requested notification frequency.</p>
	
	<p>If the authentication token expires whilst a subscription is active, the server will send a 
	subscriptionNotificationError for each subscription that can no longer be fulfilled. The client is then 
	responsible for communicating with the relevant Security Authority to renew the authentication token.</p>
	
	<p>After the client authentication token has expired, the server MAY continue to send notifications for data that
	is not subject to access control restrictions. The client will NOT receive notifications for subscriptions that require
	a valid authentication token until the client sends a renewed authentication token to the server.</p>
	
	<p> If a new authentication token is presented by the client to the server in a timely manner,	all existing subscriptions
	will continue to cause notifications to be sent from the server, provided the security principal(s)
	have not changed. The time window during which the client MAY re-authenticate and subscriptions continue WILL be 
	implementation dependent. If the server has terminated any subscriptions, it is the responsibility of the client to renew them.</p>
	
	<p>At any time the server MUST only send subscription notifications for data that the client is authorized to access.</p>

        <p>The server MAY close the WebSocket connection at any time and in so doing, terminate all subscriptions for the client. 
	The client is then responsible for renewing subscriptions. The client MUST close the WebSocket connection if the server 
	data is no longer required.</p>

  	<p>An example of a subscription can be found <a href="#introduction">here</a>.</p>

	<h2>Unsubscribe</h2>
        <p>To unsubscribe from a subscription, the client SHALL send an 'unsubscribeRequest' message to the server. This is
        comprised of a JSON structure which contains an action property set to 'unsubscribe' and a string containing the
        'subscriptionId'. If the server is able to satisfy the request it returns an 'unsubscribeSuccessResponse'. If an error
	occurs, for example because an invalid subscriptionId is passed to the server, an 'unsubscribeErrorResponse' is returned.</p>

	<p>If the client has created more than one WebSocket instance, it MUST always unsubscribe using the same WebSocket instance
	that was originally used to create the subscription.</p>

	<p>It is not possible to unsubscribe from a subset of signals within a subscription. The client must unsubscribe 
	and set up a new subscription to receive notifications for the desired signals. For example, if there is an active 
	subscription for all lights, using the path Signal.Body.Lights.*, and the client requires information for only 
	Signal.Body.Lights.IsLowBeamOn,	the client will have to unsubscribe from the Signal.Body.Lights.* subscription and 
	re-subscribe to Signal.Body.Lights.IsLowBeamOn.</p>

	<p>The client should always unsubscribe from receiving notifications when it is no longer using the data. Over a long
	vehicle journey, this significantly reduces the processing load on the server and allow the server to free memory.
	It therefore makes it more likely that the server will remain responsive to future requests from the client.</p>

  <h4 data-idl id="idl-def-unsubscriberequest">Unsubscribe Request Properties</h4>
  <p>The properties and schema for a unsubscribeRequest is:</p>
  <table class=simple>
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan='4'><dfn>unsubscribeRequest</dfn></th>
      <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
      <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    </tr>
  </tbody>
  </table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Unsubscribe Request",
    "description": "Allows the client to unsubscribe to time-varying signal notifications on the server.",
    "type": "object",
    "required": ["action", "subscriptionId", "requestId"],
    "properties": {
        "action": {
            "enum": [ "unsubscribe" ],
            "description": "The identifier for the unsubscribe request"
        },
        "subscriptionId": {
            "$ref": "#/definitions/subscriptionId"
        }, 
        "requestId": {
            "$ref": "#/definitions/requestId"
        }
    }
}
</pre>
<p>The properties and schema for a unsubscribeSuccessResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='5'><dfn>unsubscribeSuccessResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Unsubscribe Success Response",
    "description": "The response sent from the server upon a successful unsubscribe request",
    "type": "object",
    "required": ["action", "subscriptionId", "requestId", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "unsubscribe" ],
            "description": "The identifier for the unsubscribe request"
        },
        "subscriptionId": {
            "$ref": "#/definitions/subscriptionId"
        }, 
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>
<p>The properties and schema for a unsubscribeErrorResponse is:</p>
<table class=simple>
<thead>
  <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan='6'><dfn>unsubscribeErrorResponse</dfn></th>
    <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-subscriptionid">subscriptionId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
    <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
  </tr>
</tbody>
</table>
<pre>
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "Unsubscribe Error Response",
    "description": "The response sent from the server upon an unsuccessful unsubscribe request",
    "type": "object",
    "required": ["action", "subscriptionId", "requestId", "error", "timestamp"],
    "properties": {
        "action": {
            "enum": [ "unsubscribe" ],
            "description": "The identifier for the subscription request"
        },
        "subscriptionId": {
            "$ref": "#/definitions/subscriptionId"
        }, 
        "requestId": {
            "$ref": "#/definitions/requestId"
        },
        "error": {
            "$ref": "#/definitions/error"
        },
        "timestamp": {
            "$ref": "#/definitions/timestamp"
        }
    }
}
</pre>

      <h4>Examples</h4>
	The example below shows the JSON message structure for a 'unsubscribeRequest' and 'unsubscribeSuccessResponse' to unsubscribe from a single subscription.
	<pre class="highlight hljs javascript">
	client -> {
		"action": "unsubscribe",
		"subscriptionId": "102",
		"requestId": "5264"
	}

	receive <- {
		"action": "unsubscribe",
		"subscriptionId": "102",
		"requestId": "5264",
		"timestamp": 1489985044000
	}
	</pre>

	The following shows an example of error case with invalid susbscriptionId.
	<pre class="highlight hljs javascript">
	client -> {
		"action": "unsubscribe",
		"subscriptionId": "3542",
		"requestId": "7846"
	}
	receive <- {
		"action": "unsubscribe",
		"subscriptionId": "3542",
		"requestId": "7846",
		"error": { "number":404,
			"reason": "invalid_subscriptionId",
			"message": "The specified subscription was not found." },
		"timestamp": 1489985044000
	}
	</pre>

	<pre class="example highlight">
		// send unsubscribe message
		vehicle.send('{ "action": "unsubscribe", "subscriptionId": "102", "requestId": "5429" }');

		// set handler
		vehicle.onmesssage(function(event){
			var msg = JSON.parse(event.data);
			// success case
			if(msg.hasOwnProperty("requestId") && msg.requestId == "5429"){
				console.log("Successfully unsubscribed for id " + msg.subscriptionId);
			// error case
			} else if (msg.hasOwnProperty("error")) {
				console.log("Unsuccessful unsubscribe. " + msg.error.message)
			}
		});
	</pre>
        </section>

<h2>Unsubscribe All</h2>
<p>To unsubscribe from all subscriptions, the client SHALL send an 'unsubscribeAllRequest' message to the server. This is
comprised of a JSON structure which contains an action property set to 'unsubscribeAll'. This does not require a subscriptionId value. If the request is successful, or there are no active subscriptions
to unsubscribe from, the VIS Server will return an 'unsubscribeSuccessResponse'.</p>

<h4 data-idl id="idl-def-unsubscribeallrequest">Unsubscribe All Request Properties</h4>
<p>The properties and schema for a unsubscribeAllRequest is:</p>
<table class=simple>
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan='3'><dfn>unsubscribeAllRequest</dfn></th>
      <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
      <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
    </tr>
  </tbody>
</table>
<pre>
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "unsubscribeAll Request",
  "description": "Allows the client to unsubscribe from all notifications on the server.",
  "type": "object",
  "required": ["action", "requestId"],
  "properties": {
    "action": {
      "enum": [ "unsubscribeAll" ],
      "description": "The identifier for the unsubscribeAll request"
    },
    "requestId": {
      "$ref": "#/definitions/requestId"
    }
  }
}
</pre>

<p>The properties and schema for a unsubscribeAllSuccessResponse is:</p>
<table class=simple>
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan='4'><dfn>unsubscribeAllSuccessResponse</dfn></th>
      <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
      <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
    </tr>
  </tbody>
</table>
<pre>
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "unsubscribeAll Success Response",
  "description": "The response sent from the server upon a successful unsubscribeAll request",
  "type": "object",
  "required": ["action", "requestId", "timestamp"],
  "properties": {
    "action": {
      "enum": [ "unsubscribeAll" ],
      "description": "The identifier for the unsubscribeAll request"
    },
    "requestId": {
      "$ref": "#/definitions/requestId"
    },
    "timestamp": {
      "$ref": "#/definitions/timestamp"
    }
  }
}
</pre>

<p>The properties and schema for a unsubscribeAllErrorResponse is:</p>
<table class=simple>
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan='5'><dfn>unsubscribeAllErrorResponse</dfn></th>
      <tr><td><a href="#dfn-action">action</a></td><td><a href="#action">Action</a></td><td>Yes</td></tr>
      <tr><td><a href="#dfn-requestid">requestId</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#dfn-error">error</a></td><td><a href="#errors">Error</a></td><td>Yes</td></tr>
      <tr><td><a href="#dfn-timestamp">timestamp</a></td><td>integer</td><td>Yes</td></tr>
    </tr>
  </tbody>
</table>
<pre>
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "UnsubscribeAll Error Response",
  "description": "The response sent from the server upon an unsuccessful unsubscribeAll request",
  "type": "object",
  "required": ["action", "requestId", "error", "timestamp"],
  "properties": {
    "action": {
    "enum": [ "unsubscribeAll" ],
    "description": "The identifier for the unsubscribeAll request"
    },
    "requestId": {
      "$ref": "#/definitions/requestId"
    },
    "error": {
      "$ref": "#/definitions/error"
    },
    "timestamp": {
      "$ref": "#/definitions/timestamp"
    }
  }
}
</pre>

<h4>Examples</h4>
The example below shows an example of a 'unsubscribeAllRequest' and 'unsubscribeAllSuccessResponse' for unsubscribeAll action, in order to unsubscribe from all subscriptions.

<pre class="highlight hljs javascript">
client -> {
    "action": "unsubscribeAll",
    "requestId": "3468"
}

receive <- {
    "action": "unsubscribeAll",
    "requestId": "3468",
    "timestamp": 1489985044000
}
</pre>

    <section>
      <h3>Server Side Filtering</h3>
      <p>'<a>Filters</a>' may be specified to enable Server side filtering
      to be used to throttle the demands of subscriptions on
      the server. This may enable the reduction of traffic if the
      developer has received a '429 - Too Many Requests' error
      message.</p>
      
      <p>Server side filters are extensible, allowing for additional filtering mechanisms to be specified. Support 
      is currently included for a specific range of values, time intervals and
      minimum changes. This can be implemented using the "filters"
      option in the subscribeRequest interface.</p>

	<p>Filters can only be applied for data which is represented by a primitive type, such as leaf nodes in the VSS tree, not entire branches.
	For example, a filter cannot be set on Signal.Drivetrain.InternalCombustionEngine.*, 
	however it can be set on Signal.Drivetrain.InternalCombustionEngine.RPM.</p>

      <p>The default behaviour for a subscription is to request that the server sends a notification to the client 'onchange'. 
      To modify this behaviour the client can use filtering options. The following filter options SHALL be supported:</p>
      <ul>
	<li>Interval - requests that the server provides a notification every 'n' milliseconds. This allows the client to reduce the
	load on the server if the client does not need the data more frequently.</li>
	<li>Range - send a notification only when the value is in a given range.</li>
	<li>Minimum change - send a notification when a value has changed by a specified amount.</li>
      </ul>      
	<p>The client can use filters to request that the server sends notifications based on various criteria, but 
	it is important to note that this is just a request and the notification frequency will ultimately be determined by the server.</p>
      
      <h4></h4>
      <h4></h4>
      <h4>JSON Schema</h4>
<pre>
{
  "filters": {
      "$ref": "#/definitions/filters"
  }
}
</pre>      
           
      <h4>Examples</h4>
	<p>The following structures are examples of subscribeRequest objects which are requesting server side filters</p>
      <pre class="highlight hljs javascript">
	//client receives data every 100ms
	{ "action": "subscribe", "path": "&lt;any_path&gt;",
        	"filters": { "interval": 100 },
        	"requestId": "&lt;some_unique_value&gt;" }

	//client receives data when the value is between 100 and 200 (inclusive)
	{ "action": "subscribe", "path": "&lt;any_path&gt;",
        	"filters": { "range": { "above": 100, "below": 200 } },
        	"requestId": "&lt;some_unique_value&gt;" }

	//client receives data when the value is below 100 (inclusive)
	{ "action": "subscribe", "path": "&lt;any_path&gt;",
        	"filters": { "range": { "below": 100 } },
        	"requestId": "&lt;some_unique_value&gt;" }

	//client receives data when the value changes by 100 units
	{ "action": "subscribe", "path": "&lt;any_path&gt;",
        	"filters": { "minChange": 100 },
        	"requestId": "&lt;some_unique_value&gt;" }

	//client receives data when the value is above 200 (inclusive)
	//and the value changes by 20 units
	{ "action": "subscribe", "path": "&lt;any_path&gt;",
        	"filters": { "range": { "below": 200 }, "minChange": 20},
        	"requestId": "&lt;some_unique_value&gt;" }
      </pre>

      <p>The client should not specify a minimum change amount that is smaller than it needs - in order to prevent
	adding unnecessary load on the server. The server shall return a '429 - Too Many Request' error response if
	it is unable to fulfil the request made by the client.</p>

      <section>
	<h3>WebSocket Closure</h3>
	<p>The WebSocket may be closed by either the client or the
	server by invoking the ‘close()’ method on the WebSocket
	instance.</p>

	<p>The following example shows the lifetime of a WebSocket on
	the client:</p>
	<pre class="example highlight">
// Open the WebSocket
var vehicle  = new WebSocket("wss://localhost:4343", "wvss1.0");

// WebSocket is used to GET, SET, SUBSCRIBE and UNSUBSCRIBE
…

// Close the WebSocket
vehicle.close();
	</pre>
	<p>The VIS Server may terminate the WebSocket connection
	if it has not received a request for a period determined by
	the server. It is the client’s responsibility to handle this
	gracefully and to recover and request new
	subscriptions, where required.</p>

      <p>The section that follows defines the error responses that shall be supported by the server.</p>
      </section>

      <section>
	<h2>Errors</h2>
	<p>If there is an error with any of the client’s requests, the server responds with an error number, reason and
	message.</p>
  <p>The properties and schema for an Error object is:</p>
  <table class=simple>
  <thead>
    <tr><th>Object Name</th><th>Attribute</th><th>Type</th><th>Required</th></tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan='4'><dfn>Error</dfn></th>
      <tr><td><a href="#errorDefs">number</a></td><td>integer</td><td>Yes</td></tr>
      <tr><td><a href="#errorDefs">reason</a></td><td>string</td><td>Yes</td></tr>
      <tr><td><a href="#errorDefs">message</a></td><td>string</td><td>Yes</td></tr>
    </tr>
  </tbody>
  </table>
<pre>
{
  "error": {
      "$ref": "#/definitions/error"
  }
}
</pre>
<h4>Examples</h4>
        <p>For some error codes, for example '401 (Unauthorized)' there can be more than one cause.
        The error number that is returned is the HTTP Status Code Number e.g. 401.
        An error reason is also returned, this contains a pre-defined string value that
        can be used to distinguish between errors that have the same code (e.g. '401 Unauthorized)' but a difference cause.
        The error message is used to provide message text describing the cause in more detail.</p>

	<pre class="highlight hljs javascript">
      client -> { 
        "action": "subscribe",
      	"filters": { "&lt;filter_expression&gt;" },
      	"path": "&lt;any_metadata_definition&gt;",
      	"requestId": "&lt;some_unique_value&gt;" 
      }
      receive on error <- {
          "action": "subscribe",
          "requestId": "&lt;some_unique_value&gt;",
          "error":{ 
            "number": "&lt;error_num&gt;",
            "reason": "&lt;error_reason&gt;",
            "message": "&lt;error_message&gt;" 
          },
          "timestamp": "1489985044000" 
        }
	</pre>
	<p>The server implementation supports at least the error numbers and reasons listed in the table below.</p>
	<table id="errorDefs" class="parameters">
	  <tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Message</th>
	  </tr>
	  <tr>
	    <td>304 (Not Modified)</td>
        <td>not_modified</td>
	    <td>No changes have been made by the server.</td>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>bad_request	</td>
	    <td>The server is unable to fulfil the client request because the request is malformed.</td>
	  </tr>
	  <tr>
	    <td>400 (Bad Request)</td>
	    <td>filter_invalid</td>
	    <td>Filter requested on non-primitive type.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>user_token_expired</td>
	    <td>User token has expired.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>user_token_invalid</td>
	    <td>User token is invalid.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>user_token_missing</td>
	    <td>User token is missing.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>device_token_expired</td>
	    <td>Device token has expired.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>device_token_invalid</td>
	    <td>Device token is invalid.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>device_token_missing</td>
	    <td>Device token is missing.</td>
	  </tr>
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>too_many_attempts</td>
	    <td>The client has failed to authenticate too many times.</td>
	  </tr>	  
	  <tr>
	    <td>401 (Unauthorized)</td>
	    <td>read_only</td>
	    <td>The desired signal cannot be set since it is a read only signal.</td>
	  </tr>	
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>user_forbidden</td>
	    <td>The user is not permitted to access the requested resource. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>user_unknown</td>
	    <td>The user is unknown. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>device_forbidden</td>
	    <td>The device is not permitted to access the requested resource. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>403 (Forbidden)</td>
	    <td>device_unknown</td>
	    <td>The device is unknown. Retrying does not help.</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>invalid_path</td>
	    <td>The specified data path does not exist.</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>private_path</td>
	    <td>The specified data path is private and the request is not authorized to access signals on this path.</td>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>invalid_subscriptionId</td>
	    <td>The specified subscription was not found.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>not_acceptable</td>
	    <td>The server is unable to generate content that is acceptable to the client</td>
	  </tr>
	  <tr>
	    <td>429 (Too Many Requests)</td>
	    <td>too_many_requests</td>
	    <td>The client has sent the server too many requests in a given amount of time.</td>
	  </tr>
	  <tr>
	    <td>502 (Bad Gateway)</td>
	    <td>bad_gateway</td>
	    <td>The server was acting as a gateway or proxy and received an invalid response from an upstream server.</td>
	  </tr>
	  <tr>
	    <td>503 (Service Unavailable)</td>
	    <td>service_unavailable</td>
	    <td>The server is currently unable to handle the request due to a temporary overload or scheduled maintenance (which may be alleviated after some delay).</td>
	  </tr>
	  <tr>
	    <td>504 (Gateway Timeout)</td>
	    <td>gateway_timeout</td>
	    <td>The server did not receive a timely response from an upstream server it needed to access in order to complete the request.</td>
	  </tr>
	</table>

        <p>The server may optionally return additional error codes. It is expected that if this is the case, they are defined in the Server Documentation.
        Wherever possible the Server returns a standard HTTP error code where one has been defined for the error condition.
        See for example <a href="https://tools.ietf.org/html/rfc7231">RFC7231</a>, <a href="https://tools.ietf.org/html/rfc7235">RFC7235</a>,
        and <a href="https://tools.ietf.org/html/rfc6585">RFC6585</a>.</p>
      </section>
    </body>
</html>
